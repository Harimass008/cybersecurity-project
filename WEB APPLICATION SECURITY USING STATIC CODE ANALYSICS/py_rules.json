
{
    "rules": [
      {
        "id": "python01",
        "title": "HTTP Response Headers Should Not Be Vulnerable to Response Splitting Attacks",
        "description": "Detects instances where user-supplied data is improperly validated or sanitized before being included in HTTP response headers. This can lead to HTTP Response Splitting attacks, where an attacker manipulates the input to create unauthorized HTTP responses, potentially resulting in Cross-Site Scripting (XSS), phishing, cache poisoning, or malware delivery.",
        "impact": "Blocker",
        "category": "Security",
        "tags": ["security", "vulnerability", "blocker", "injection", "http", "cwe"],
        "severity": "Blocker",
        "cwe": "CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')",
        "examples": {
          "positive": [
            {
              "code": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    safe_value = request.args.get('value', 'default_value')\n    safe_value = safe_value.replace('\\r', '').replace('\\n', '')\n    response = make_response('Hello, World!')\n    response.headers['X-Header'] = safe_value\n    return response",
              "description": "This compliant code example properly sanitizes user input by removing CRLF sequences before including it in an HTTP response header, thus preventing HTTP Response Splitting."
            }
          ],
          "negative": [
            {
              "code": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    value = request.args.get('value')\n    response = make_response('Hello, World!')\n    response.headers['X-Header'] = value  # Noncompliant\n    return response",
              "description": "This noncompliant code example includes user-supplied data directly in the HTTP response header without validation or sanitization, making it vulnerable to HTTP Response Splitting attacks.",
              "pattern": "response\\s*\\.headers\\s*\\[\\s*['\"][^'\"]+['\"]\\s*\\]\\s*=\\s*request\\s*\\.args\\s*\\.get\\s*\\(\\s*['\"][^'\"]*['\"]\\s*(?:,\\s*['\"][^'\"]*['\"])?\\s*\\)"
            }
          ]
        },
        "fix": {  
          "steps": [
            "Ensure all user-supplied data included in HTTP response headers is properly validated or sanitized.",
            "Remove or escape CRLF sequences from any user input before including it in headers.",
            "Consider using frameworks or libraries that automatically handle header construction securely.",
            "Regularly review and audit code that constructs HTTP responses to identify and mitigate potential vulnerabilities."
          ],
          "examples": [
            {
              "code": "from flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    safe_value = request.args.get('value', 'default_value')\n    safe_value = safe_value.replace('\\r', '').replace('\\n', '')\n    response = make_response('Hello, World!')\n    response.headers['X-Header'] = safe_value\n    return response",
              "description": "This compliant solution demonstrates proper sanitization of user input, removing CRLF sequences before including it in an HTTP response header."
            }
          ]
        },
        "rationale": "HTTP Response Splitting is a severe security vulnerability that can lead to various attacks, such as XSS, phishing, and cache poisoning. By ensuring that user input is properly validated and sanitized before inclusion in HTTP headers, developers can prevent these attacks and protect the integrity of their web applications."
      },
      {
            "id": "python02",
            "title": "JWT Secret Keys Should Not Be Disclosed",
            "description": "Detects instances where JWT secret keys are hard-coded or otherwise exposed in source code, leading to potential security vulnerabilities. Exposure of secret keys can allow attackers to forge authentication tokens, bypass security controls, and gain unauthorized access to sensitive data or system functionality.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "jwt", "authentication", "cwe"],
            "severity": "Blocker",
            "cwe": "CWE-798: Use of Hard-coded Credentials",
            "examples": {
              "positive": [
                {
                  "code": "import os\n\nJWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')",
                  "description": "This compliant code example retrieves the JWT secret key from an environment variable, avoiding hard-coding sensitive information in the source code."
                },
                {
                  "code": "from cryptography.fernet import Fernet\n\nkey = Fernet.generate_key()\n# Store key securely and use it for JWT encoding/decoding",
                  "description": "This example shows how to generate and securely manage a secret key for JWT operations without hard-coding it in the source code."
                }
              ],
              "negative": [
                {
                  "code": "JWT_SECRET_KEY = 'supersecretkey'  # Noncompliant",
                  "description": "This noncompliant code example hard-codes a JWT secret key directly in the source code, making it vulnerable to disclosure and exploitation.",
                  "pattern": "JWT_SECRET_KEY\\s*=\\s*['\"][^'\"]+['\"]"
                },
                {
                  "code": "SECRET_KEY = 'myjwtsecret'  # Noncompliant",
                  "description": "This code example demonstrates a similar vulnerability where a sensitive JWT secret key is hard-coded, risking exposure to unauthorized parties.",
                  "pattern": "SECRET_KEY\\s*=\\s*['\"][^'\"]+['\"]"
                }
              ]
            },
            "fix": {
              "steps": [
                "Remove hard-coded JWT secret keys from the source code.",
                "Store JWT secret keys in secure environment variables or external configuration files that are properly access-controlled.",
                "Use a key management service (KMS) or a secure vault to store and retrieve JWT secret keys.",
                "Ensure that secret keys are never logged or exposed through any other means in the application."
              ],
              "examples": [
                {
                  "code": "import os\n\nJWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')",
                  "description": "This compliant solution demonstrates retrieving the JWT secret key from an environment variable, thereby keeping the key secure and out of the source code."
                },
                {
                  "code": "from cryptography.fernet import Fernet\n\nkey = Fernet.generate_key()\n# Store key securely and use it for JWT encoding/decoding",
                  "description": "This example illustrates how to securely generate and manage a JWT secret key without exposing it in the code."
                }
              ]
            },
            "rationale": "Exposing JWT secret keys in source code violates trust boundaries and significantly weakens the security of the application. By storing secret keys securely and outside the source code, developers can prevent unauthorized access and protect the integrity of the authentication system."
          },
          {
            "id": "python03",
            "title": "Flask Secret Keys Should Not Be Disclosed",
            "description": "Detects instances where Flask secret keys are hard-coded or otherwise exposed in the source code, leading to significant security vulnerabilities. Flask secret keys are used to sign cookies and other sensitive data, and their exposure can allow attackers to forge cookies, bypass authentication, and perform malicious actions.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "flask", "authentication", "cwe"],
            "severity": "Blocker",
            "cwe": "CWE-798: Use of Hard-coded Credentials",
            "examples": {
              "positive": [
                {
                  "code": "import os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.getenv('FLASK_SECRET_KEY')",
                  "description": "This compliant code example retrieves the Flask secret key from an environment variable, avoiding hard-coding sensitive information in the source code."
                },
                {
                  "code": "from cryptography.fernet import Fernet\n\nkey = Fernet.generate_key()\n# Store key securely and use it for Flask secret key",
                  "description": "This example shows how to generate and securely manage a secret key for Flask applications without hard-coding it in the source code."
                }
              ],
              "negative": [
                {
                  "code": "app = Flask(__name__)\napp.config['SECRET_KEY'] = 'supersecretkey'  # Noncompliant",
                  "description": "This noncompliant code example hard-codes a Flask secret key directly in the source code, making it vulnerable to disclosure and exploitation.",
                  "pattern": "app\\.config\\['SECRET_KEY'\\]\\s*=\\s*['\"][^'\"]+['\"]"
                },
                {
                  "code": "SECRET_KEY = 'myflasksecret'  # Noncompliant",
                  "description": "This code example demonstrates a similar vulnerability where a sensitive Flask secret key is hard-coded, risking exposure to unauthorized parties.",
                  "pattern": "SECRET_KEY\\s*=\\s*['\"][^'\"]+['\"]"
                }
              ]
            },
            "fix": {
              "steps": [
                "Remove hard-coded Flask secret keys from the source code.",
                "Store Flask secret keys in secure environment variables or external configuration files that are properly access-controlled.",
                "Use a key management service (KMS) or a secure vault to store and retrieve Flask secret keys.",
                "Ensure that secret keys are never logged or exposed through any other means in the application."
              ],
              "examples": [
                {
                  "code": "import os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.getenv('FLASK_SECRET_KEY')",
                  "description": "This compliant solution demonstrates retrieving the Flask secret key from an environment variable, thereby keeping the key secure and out of the source code."
                },
                {
                  "code": "from cryptography.fernet import Fernet\n\nkey = Fernet.generate_key()\n# Store key securely and use it for Flask secret key",
                  "description": "This example illustrates how to securely generate and manage a Flask secret key without exposing it in the code."
                }
              ]
            },
            "rationale": "Exposing Flask secret keys in source code violates trust boundaries and significantly weakens the security of the application. By securely storing secret keys outside the source code, developers can prevent unauthorized access and protect the integrity of the application's authentication and session management."
          },
          {
            "id": "python04",
            "title": "Hard-Coded Secrets Should Not Be Exposed",
            "description": "Detects instances where secrets, such as API keys or authentication tokens, are hard-coded in the source code, leading to security vulnerabilities. Hard-coded secrets can be exposed to unintended audiences, leading to unauthorized access to sensitive resources.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "authentication", "cwe", "secret-leak"],
            "severity": "Blocker",
            "cwe": "CWE-798: Use of Hard-coded Credentials",
            "examples": {
              "positive": [
                {
                  "code": "import os\n\nAPI_KEY = os.getenv('API_KEY')",
                  "description": "This compliant code example retrieves an API key from an environment variable, avoiding hard-coding sensitive information in the source code."
                },
                {
                  "code": "from cryptography.fernet import Fernet\n\nkey = Fernet.generate_key()\n# Store key securely and use it for encryption",
                  "description": "This example shows how to generate and securely manage an encryption key without hard-coding it in the source code."
                }
              ],
              "negative": [
                {
                  "code": "API_KEY = 'mysecretapikey'  # Noncompliant",
                  "description": "This noncompliant code example hard-codes an API key directly in the source code, making it vulnerable to disclosure and exploitation.",
                  "pattern": "API_KEY\\s*=\\s*['\"][^'\"]+['\"]"
                },
                {
                  "code": "AUTH_TOKEN = 'securetoken'  # Noncompliant",
                  "description": "This code example demonstrates a similar vulnerability where an authentication token is hard-coded, risking exposure to unauthorized parties.",
                  "pattern": "AUTH_TOKEN\\s*=\\s*['\"][^'\"]+['\"]"
                }
              ]
            },
            "fix": {
              "steps": [
                "Remove hard-coded secrets from the source code.",
                "Store secrets in secure environment variables or external configuration files that are properly access-controlled.",
                "Use a key management service (KMS) or a secure vault to store and retrieve secrets.",
                "Ensure that secrets are never logged or exposed through any other means in the application."
              ],
              "examples": [
                {
                  "code": "import os\n\nAPI_KEY = os.getenv('API_KEY')",
                  "description": "This compliant solution demonstrates retrieving an API key from an environment variable, thereby keeping the key secure and out of the source code."
                },
                {
                  "code": "from cryptography.fernet import Fernet\n\nkey = Fernet.generate_key()\n# Store key securely and use it for encryption",
                  "description": "This example illustrates how to securely generate and manage an encryption key without exposing it in the code."
                }
              ]
            },
            "rationale": "Exposing secrets in source code violates trust boundaries and significantly weakens the security of the application. By securely storing secrets outside the source code, developers can prevent unauthorized access and protect sensitive resources."
          },
          {
            "id": "python05",
            "title": "Server-Side Templates Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where server-side templates are potentially vulnerable to injection attacks. These vulnerabilities occur when user input is directly embedded into templates without proper sanitization, allowing attackers to inject malicious code.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "injection", "template", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-1336: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)",
            "examples": {
              "positive": [
                {
                  "code": "from jinja2 import Template\n\n# Safe usage with input sanitization\nuser_input = sanitize_input(request.args.get('name'))\ntemplate = Template('Hello, {{ name }}!')\noutput = template.render(name=user_input)",
                  "description": "This compliant code example demonstrates safe usage of a server-side template by sanitizing user input before rendering it, preventing injection attacks."
                },
                {
                  "code": "from flask import render_template\n\n# Safe rendering with Flask\n@app.route('/welcome')\ndef welcome():\n    user_input = sanitize_input(request.args.get('name'))\n    return render_template('welcome.html', name=user_input)",
                  "description": "This example shows how to safely pass user input to a Flask template after proper sanitization, mitigating the risk of server-side template injection."
                }
              ],
              "negative": [
                {
                  "code": "from jinja2 import Template\n\n# Vulnerable to injection\nuser_input = request.args.get('name')\ntemplate = Template('Hello, {{ name }}!')\noutput = template.render(name=user_input)  # Noncompliant",
                  "description": "This noncompliant code example directly injects user input into a Jinja2 template without sanitization, making it vulnerable to injection attacks.",
                  "pattern": "Template\\(.*\\)\\.render\\(.*request\\.args\\.get\\(['\"][^'\"]+['\"]\\)"
                },
                {
                  "code": "@app.route('/greet')\ndef greet():\n    user_input = request.args.get('name')\n    return render_template_string(f'Hello, {user_input}!')  # Noncompliant",
                  "description": "This example demonstrates a similar vulnerability where user input is embedded directly into a Flask template string, risking injection attacks.",
                  "pattern": "render_template_string\\(.*request\\.args\\.get\\(['\"][^'\"]+['\"]\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Sanitize all user inputs before embedding them into server-side templates.",
                "Avoid using untrusted user input directly in template expressions.",
                "Use built-in sanitization features provided by the template engine or web framework.",
                "Consider using safer alternatives like context-sensitive escaping or strict template modes."
              ],
              "examples": [
                {
                  "code": "from jinja2 import Template\n\n# Compliant code with input sanitization\nuser_input = sanitize_input(request.args.get('name'))\ntemplate = Template('Hello, {{ name }}!')\noutput = template.render(name=user_input)",
                  "description": "This compliant solution demonstrates sanitizing user input before embedding it in a Jinja2 template, preventing injection attacks."
                },
                {
                  "code": "from flask import render_template\n\n# Compliant rendering in Flask\n@app.route('/welcome')\ndef welcome():\n    user_input = sanitize_input(request.args.get('name'))\n    return render_template('welcome.html', name=user_input)",
                  "description": "This example illustrates safe usage of the Flask `render_template` function with sanitized user input, mitigating the risk of server-side template injection."
                }
              ]
            },
            "rationale": "Server-side template injection vulnerabilities can lead to severe security breaches, including remote code execution, data leaks, and privilege escalation. By sanitizing user inputs and using secure template rendering practices, developers can protect their applications from such attacks."
          },
          {
            "id": "python06",
            "title": "Dynamic Code Execution Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where dynamic code execution functions, such as eval() or exec(), are used with untrusted input. Such practices can lead to code injection vulnerabilities, allowing attackers to execute arbitrary code within the application's context.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "injection", "code-execution", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-94: Improper Control of Generation of Code ('Code Injection')",
            "examples": {
              "positive": [
                {
                  "code": "import ast\n\n# Safe evaluation of mathematical expressions\nuser_input = request.args.get('expression')\ntry:\n    parsed_expr = ast.literal_eval(user_input)\nexcept (ValueError, SyntaxError):\n    parsed_expr = None\n# Proceed with parsed_expr safely",
                  "description": "This compliant code example uses `ast.literal_eval` to safely evaluate user-provided expressions, avoiding the risks associated with `eval()`."
                },
                {
                  "code": "# Avoiding dynamic code execution altogether\nallowed_operations = {'add': lambda x, y: x + y}\nuser_operation = request.args.get('operation')\nif user_operation in allowed_operations:\n    result = allowed_operations[user_operation](a, b)\nelse:\n    result = None",
                  "description": "This example avoids dynamic code execution by using predefined functions and checking user input against allowed operations."
                }
              ],
              "negative": [
                {
                  "code": "user_code = request.args.get('code')\neval(user_code)  # Noncompliant",
                  "description": "This noncompliant code example directly evaluates user input using `eval()`, making it vulnerable to code injection attacks.",
                  "pattern": "eval\\(.*request\\.args\\.get\\(['\"][^'\"]+['\"]\\)"
                },
                {
                  "code": "exec(request.form['command'])  # Noncompliant",
                  "description": "This example demonstrates a similar vulnerability where user input from a form is executed using `exec()`, risking arbitrary code execution.",
                  "pattern": "exec\\(.*request\\.form\\['[^']+'\\]\\)"
                },
                {
                  "code": "from subprocess import call\ncommand = request.args.get('cmd')\ncall(command, shell=True)  # Noncompliant",
                  "description": "This code executes user-provided commands in the shell without sanitization, leading to potential command injection.",
                  "pattern": "call\\(.*request\\.args\\.get\\(['\"][^'\"]+['\"]\\).*shell=True\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Avoid using dynamic code execution functions like `eval()` and `exec()` with untrusted input.",
                "If dynamic evaluation is necessary, use safer alternatives like `ast.literal_eval()` for evaluating expressions.",
                "Implement strict input validation and sanitization to ensure only safe and expected inputs are processed.",
                "Use predefined functions or mappings to handle user requests instead of executing arbitrary code.",
                "Avoid using the `shell=True` parameter in subprocess calls when incorporating user input."
              ],
              "examples": [
                {
                  "code": "import ast\n\n# Compliant code using ast.literal_eval\nuser_input = request.args.get('expression')\ntry:\n    parsed_expr = ast.literal_eval(user_input)\nexcept (ValueError, SyntaxError):\n    parsed_expr = None\n# Proceed with parsed_expr safely",
                  "description": "This compliant solution demonstrates using `ast.literal_eval` to safely parse user-provided expressions, mitigating the risk of code injection."
                },
                {
                  "code": "from subprocess import run\nuser_command = request.args.get('cmd')\n# Validate and sanitize user_command before using it\nsafe_commands = {'list': ['ls', '-l'], 'status': ['systemctl', 'status']}\nif user_command in safe_commands:\n    run(safe_commands[user_command])\nelse:\n    pass  # Handle invalid command",
                  "description": "This example illustrates how to execute only predefined and safe commands, avoiding the use of `shell=True` and preventing command injection."
                }
              ]
            },
            "rationale": "Using dynamic code execution functions with untrusted input poses a significant security risk, as attackers can inject and execute arbitrary code. This can lead to unauthorized data access, data leaks, denial of service, or complete system compromise. By avoiding or securely handling dynamic code execution, developers can protect applications from such critical vulnerabilities."
          },
          {
            "id": "python07",
            "title": "NoSQL Operations Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where NoSQL database queries are constructed with untrusted input, leading to injection vulnerabilities. These vulnerabilities can allow attackers to manipulate database queries and execute unauthorized operations, such as data leakage or deletion.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "injection", "nosql", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-943: Improper Neutralization of Special Elements in Data Query Logic (NoSQL Injection)",
            "examples": {
              "positive": [
                {
                  "code": "from pymongo import MongoClient\n\n# Secure query construction using parameterized queries\nclient = MongoClient()\ndb = client.mydatabase\nuser_id = request.args.get('user_id')\nresult = db.users.find_one({'_id': ObjectId(user_id)})",
                  "description": "This compliant code example uses a parameterized query to safely retrieve a user document from a MongoDB database, avoiding NoSQL injection."
                },
                {
                  "code": "from pymongo import MongoClient\n\n# Properly validating and sanitizing user input\nclient = MongoClient()\ndb = client.mydatabase\nuser_input = sanitize_input(request.args.get('name'))\nresult = db.users.find_one({'name': user_input})",
                  "description": "This example demonstrates proper validation and sanitization of user input before using it in a MongoDB query, mitigating the risk of injection attacks."
                }
              ],
              "negative": [
                {
                  "code": "from pymongo import MongoClient\n\nclient = MongoClient()\ndb = client.mydatabase\nuser_input = request.args.get('name')\nresult = db.users.find_one({'name': user_input})  # Noncompliant",
                  "description": "This noncompliant code example directly uses untrusted user input in a MongoDB query, making it vulnerable to NoSQL injection.",
                  "pattern": "find_one\\(.*request\\.args\\.get\\(['\"][^'\"]+['\"]\\)"
                },
                {
                  "code": "from pymongo import MongoClient\n\nclient = MongoClient()\ndb = client.mydatabase\nquery = request.args.get('query')\nresult = db.users.find(eval(query))  # Noncompliant",
                  "description": "This example demonstrates a severe vulnerability where user input is evaluated and used directly in a NoSQL query, leading to a high risk of injection attacks.",
                  "pattern": "find\\(eval\\(.*request\\.args\\.get\\(['\"][^'\"]+['\"]\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Use parameterized queries or prepared statements for NoSQL operations to ensure that untrusted input is not directly embedded in the query.",
                "Implement strict input validation and sanitization to allow only expected and safe input values in database queries.",
                "Avoid using functions like `eval()` or similar methods that execute user input as code or database query logic.",
                "When constructing queries dynamically, ensure that input is properly escaped and that only safe operations are allowed.",
                "Consider using ObjectId or similar strict typing mechanisms provided by the database library to validate input types."
              ],
              "examples": [
                {
                  "code": "from pymongo import MongoClient\n\n# Compliant query using ObjectId\nclient = MongoClient()\ndb = client.mydatabase\nuser_id = request.args.get('user_id')\ntry:\n    object_id = ObjectId(user_id)\n    result = db.users.find_one({'_id': object_id})\nexcept InvalidId:\n    result = None  # Handle invalid ObjectId",
                  "description": "This compliant solution uses MongoDB's `ObjectId` to safely convert and validate user input before using it in a query, preventing injection attacks."
                },
                {
                  "code": "from pymongo import MongoClient\n\n# Safe query with input sanitization\nclient = MongoClient()\ndb = client.mydatabase\nuser_input = sanitize_input(request.args.get('query'))\nresult = db.users.find({'query': user_input})",
                  "description": "This example illustrates proper input sanitization before using it in a MongoDB query, thereby mitigating the risk of NoSQL injection."
                }
              ]
            },
            "rationale": "NoSQL injection vulnerabilities allow attackers to manipulate database queries by injecting malicious input. This can result in unauthorized access, data leakage, data deletion, or even complete database compromise. By using secure query construction practices and validating all user inputs, developers can protect their applications from these critical vulnerabilities."
          },
          {
            "id": "python08",
            "title": "HTTP Request Redirections Should Not Be Open to Forging Attacks",
            "description": "Detects instances where user-controllable data is used to construct HTTP redirections, leading to potential open redirection vulnerabilities. These vulnerabilities can be exploited by attackers to redirect users to malicious sites, facilitating phishing, malware distribution, and other attacks.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "injection", "redirection", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')",
            "examples": {
              "positive": [
                {
                  "code": "from flask import redirect, request, url_for\n\n# Safe redirection using a fixed URL or a safe list\n@app.route('/redirect')\ndef safe_redirect():\n    target = request.args.get('next')\n    if target and is_safe_url(target):\n        return redirect(target)\n    return redirect(url_for('home'))",
                  "description": "This compliant code example checks if the user-supplied URL is in a whitelist of safe URLs before performing the redirection, preventing open redirection attacks."
                },
                {
                  "code": "from flask import redirect, request, url_for\n\n# Safe redirection to internal URLs only\n@app.route('/redirect')\ndef internal_redirect():\n    target = request.args.get('next')\n    if target and target.startswith('/'):  # Only allow relative paths\n        return redirect(target)\n    return redirect(url_for('home'))",
                  "description": "This example limits redirection to internal paths only, mitigating the risk of redirecting to a malicious external site."
                }
              ],
              "negative": [
                {
                  "code": "from flask import redirect, request\n\n@app.route('/redirect')\ndef unsafe_redirect():\n    target = request.args.get('next')\n    return redirect(target)  # Noncompliant",
                  "description": "This noncompliant code example directly uses untrusted user input for redirection without validation, making it vulnerable to open redirection attacks.",
                  "pattern": "redirect\\(request\\.args\\.get\\(['\"][^'\"]+['\"]\\)"
                },
                {
                  "code": "from flask import redirect, request\n\n@app.route('/go')\ndef vulnerable_redirect():\n    url = request.args.get('url')\n    return redirect(url)  # Noncompliant",
                  "description": "This example demonstrates a similar vulnerability where untrusted input is directly used in a redirection, allowing attackers to craft malicious URLs.",
                  "pattern": "redirect\\(request\\.args\\.get\\(['\"][^'\"]+['\"]\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Validate and sanitize user input used for constructing redirection URLs to ensure that only safe and expected URLs are allowed.",
                "Restrict redirections to internal URLs or a whitelist of trusted external URLs.",
                "Use functions like `url_for` in Flask to generate safe redirection URLs within the application.",
                "Avoid allowing user input to directly influence redirection logic without proper checks."
              ],
              "examples": [
                {
                  "code": "from flask import redirect, request, url_for\n\n# Compliant code with safe redirection\n@app.route('/redirect')\ndef safe_redirect():\n    target = request.args.get('next')\n    if target and is_safe_url(target):\n        return redirect(target)\n    return redirect(url_for('home'))",
                  "description": "This compliant solution ensures that user input is validated against a list of safe URLs before redirection, preventing open redirection attacks."
                },
                {
                  "code": "from flask import redirect, request, url_for\n\n# Safe redirection to internal URLs\n@app.route('/redirect')\ndef internal_redirect():\n    target = request.args.get('next')\n    if target and target.startswith('/'):  # Only allow relative paths\n        return redirect(target)\n    return redirect(url_for('home'))",
                  "description": "This example restricts redirections to internal paths only, mitigating the risk of redirecting users to malicious external sites."
                }
              ]
            },
            "rationale": "Open redirection vulnerabilities can lead to various attacks, including phishing, malware distribution, and credential theft. By validating redirection targets and limiting them to safe or internal URLs, developers can protect users from being redirected to malicious sites and prevent the exploitation of open redirect flaws."
          },
          {
            "id": "python09",
            "title": "Deserialization Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where untrusted data is deserialized without proper validation, leading to deserialization vulnerabilities. These vulnerabilities can allow attackers to inject malicious objects or code, leading to potential unauthorized actions or full system compromise.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "injection", "deserialization", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-502: Deserialization of Untrusted Data",
            "examples": {
              "positive": [
                {
                  "code": "import json\n\n# Safe deserialization using strict schema validation\nclass UserSchema(Schema):\n    name = fields.Str(required=True)\n    age = fields.Int(required=True)\n\nuser_data = request.get_json()\ntry:\n    valid_data = UserSchema().load(user_data)\nexcept ValidationError as e:\n    abort(400, str(e))\n# Proceed with valid_data",
                  "description": "This compliant code example deserializes JSON data using a strict schema validation, ensuring that only expected and safe data is processed."
                },
                {
                  "code": "import pickle\n\n# Safe deserialization using a safe, restricted environment\ntrusted_data = request.get_json()\nif validate(trusted_data):\n    safe_object = pickle.loads(trusted_data)  # Only after thorough validation",
                  "description": "This example ensures that untrusted data is thoroughly validated before deserialization with `pickle`, reducing the risk of malicious payloads."
                }
              ],
              "negative": [
                {
                  "code": "import pickle\n\n# Unsafe deserialization\nuser_input = request.get_data()\nobj = pickle.loads(user_input)  # Noncompliant",
                  "description": "This noncompliant code example directly deserializes untrusted user input using `pickle`, making it vulnerable to deserialization attacks.",
                  "pattern": "pickle\\.loads\\(request\\.get_data\\(\\)\\)"
                },
                {
                  "code": "import yaml\n\n# Unsafe deserialization\nuser_input = request.get_data()\ndata = yaml.load(user_input, Loader=yaml.FullLoader)  # Noncompliant",
                  "description": "This example demonstrates a vulnerability where untrusted YAML data is deserialized without validation, exposing the application to potential injection attacks.",
                  "pattern": "yaml\\.load\\(request\\.get_data\\(\\), Loader=yaml\\.FullLoader\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Avoid deserializing untrusted or unvalidated data whenever possible.",
                "Use strict schema validation to ensure that only expected and safe data types and structures are deserialized.",
                "Consider using safer alternatives to deserialization, such as JSON with strict validation, instead of more dangerous methods like `pickle` or `yaml.load()`.",
                "When deserialization is necessary, ensure that the data is thoroughly sanitized and validated before the process.",
                "Implement a secure deserialization framework that restricts or filters out dangerous classes or types that could lead to code execution."
              ],
              "examples": [
                {
                  "code": "import json\n\n# Compliant deserialization with schema validation\nclass UserSchema(Schema):\n    name = fields.Str(required=True)\n    age = fields.Int(required=True)\n\nuser_data = request.get_json()\ntry:\n    valid_data = UserSchema().load(user_data)\nexcept ValidationError as e:\n    abort(400, str(e))\n# Proceed with valid_data",
                  "description": "This compliant solution demonstrates using schema validation to ensure that only safe and expected data is deserialized, preventing deserialization attacks."
                },
                {
                  "code": "import pickle\n\n# Safe deserialization after validation\ntrusted_data = request.get_json()\nif validate(trusted_data):\n    safe_object = pickle.loads(trusted_data)  # Only after thorough validation",
                  "description": "This example illustrates the importance of validating untrusted input before deserializing it with potentially dangerous methods like `pickle`."
                }
              ]
            },
            "rationale": "Deserialization of untrusted data poses a significant security risk, as attackers can craft payloads that lead to unauthorized actions, data manipulation, or even full system compromise. By ensuring that all deserialized data is validated and sanitized, developers can protect their applications from these critical vulnerabilities."
          },
          {
            "id": "python10",
            "title": "Endpoints Should Not Be Vulnerable to Reflected Cross-Site Scripting (XSS) Attacks",
            "description": "Detects instances where user-controllable data, such as URL parameters, is reflected in the HTML body of an HTTP response without proper sanitization. This can lead to reflected XSS vulnerabilities, allowing attackers to execute malicious JavaScript code in the context of the victim's session.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "injection", "xss", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
            "examples": {
              "positive": [
                {
                  "code": "from flask import request, render_template_string, escape\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    return render_template_string('<h1>Results for {{ query }}</h1>', query=escape(query))",
                  "description": "This compliant code example properly escapes user input before reflecting it in the HTTP response, preventing reflected XSS."
                },
                {
                  "code": "from flask import request, render_template\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    return render_template('search_results.html', query=query)",
                  "description": "This example shows how to use Flask's `render_template` with automatic escaping, mitigating the risk of reflected XSS."
                }
              ],
              "negative": [
                {
                  "code": "from flask import request, render_template_string\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    return render_template_string('<h1>Results for {{ query }}</h1>', query=query)  # Noncompliant",
                  "description": "This noncompliant code example directly reflects user input into the HTML response without escaping, making it vulnerable to reflected XSS.",
                  "pattern": "render_template_string\\(.*request\\.args\\.get\\(['\"][^'\"]+['\"]\\)"
                },
                {
                  "code": "from flask import request\n\n@app.route('/greet')\ndef greet():\n    name = request.args.get('name')\n    return f'<h1>Hello, {name}!</h1>'  # Noncompliant",
                  "description": "This example demonstrates a vulnerability where untrusted user input is directly inserted into an HTML response, leading to reflected XSS.",
                  "pattern": "return f?['\"]<.*{request\\.args\\.get\\(['\"][^'\"]+['\"]\\)}.*['\"]"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always escape user input before inserting it into an HTML response to prevent reflected XSS.",
                "Use built-in templating engines like Jinja2 in Flask, which automatically escape user input by default.",
                "Avoid constructing HTML responses by concatenating strings or using formatted strings with untrusted user input.",
                "Implement Content Security Policy (CSP) headers to reduce the risk of XSS attacks.",
                "Use libraries like `bleach` in Python to sanitize HTML content and remove or escape potentially dangerous elements."
              ],
              "examples": [
                {
                  "code": "from flask import request, render_template_string, escape\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    return render_template_string('<h1>Results for {{ query }}</h1>', query=escape(query))",
                  "description": "This compliant solution properly escapes user input before reflecting it in the HTTP response, preventing reflected XSS."
                },
                {
                  "code": "from flask import request, render_template\n\n@app.route('/search')\ndef search():\n    query = request.args.get('q')\n    return render_template('search_results.html', query=query)",
                  "description": "This example demonstrates the use of Flask's `render_template`, which safely escapes user input by default, mitigating the risk of reflected XSS."
                }
              ]
            },
            "rationale": "Reflected XSS vulnerabilities allow attackers to execute arbitrary JavaScript code in the context of the victim's browser, leading to session hijacking, data theft, or other malicious actions. By properly sanitizing and escaping user input before reflecting it in an HTTP response, developers can prevent these critical security flaws."
          },
          {
            "id": "python12",
            "title": "XML Parsers Should Not Be Vulnerable to XXE Attacks",
            "description": "Detects instances where XML parsers are configured to process external entities, leading to XML External Entity (XXE) vulnerabilities. These vulnerabilities can allow attackers to exploit the XML parser to access sensitive data, perform denial of service attacks, or conduct server-side request forgery (SSRF) attacks.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "xxe", "xml", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-611: Improper Restriction of XML External Entity Reference ('XXE')",
            "examples": {
              "positive": [
                {
                  "code": "import defusedxml.ElementTree as ET\n\n# Safe XML parsing with defusedxml\nxml_data = request.data\nroot = ET.fromstring(xml_data)",
                  "description": "This compliant code example uses `defusedxml`, a library designed to protect against XML vulnerabilities, including XXE attacks."
                },
                {
                  "code": "import lxml.etree as etree\n\n# Safe XML parsing with lxml by disabling external entities\nparser = etree.XMLParser(resolve_entities=False)\nxml_data = request.data\nroot = etree.fromstring(xml_data, parser)",
                  "description": "This example shows how to configure the `lxml` parser to disable external entity resolution, preventing XXE attacks."
                }
              ],
              "negative": [
                {
                  "code": "import xml.etree.ElementTree as ET\n\nxml_data = request.data\nroot = ET.fromstring(xml_data)  # Noncompliant",
                  "description": "This noncompliant code example uses the standard `xml.etree.ElementTree` module without disabling external entity processing, making it vulnerable to XXE attacks.",
                  "pattern": "ET\\.fromstring\\(request\\.data\\)"
                },
                {
                  "code": "import lxml.etree as etree\n\nxml_data = request.data\nroot = etree.fromstring(xml_data)  # Noncompliant",
                  "description": "This example demonstrates a vulnerability where `lxml` is used without disabling external entity resolution, exposing the application to XXE attacks.",
                  "pattern": "etree\\.fromstring\\(request\\.data\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Use secure libraries like `defusedxml` to parse XML data, which is specifically designed to prevent XML-related vulnerabilities, including XXE.",
                "If using libraries like `lxml`, disable external entity processing by configuring the parser with `resolve_entities=False`.",
                "Avoid using the standard `xml.etree.ElementTree` module for parsing untrusted XML data without proper safeguards against XXE.",
                "Regularly update XML parsing libraries to ensure that any security patches related to XXE vulnerabilities are applied.",
                "Consider implementing strict input validation and sanitization before parsing XML data to reduce the risk of XXE attacks."
              ],
              "examples": [
                {
                  "code": "import defusedxml.ElementTree as ET\n\n# Compliant XML parsing with defusedxml\nxml_data = request.data\nroot = ET.fromstring(xml_data)",
                  "description": "This compliant solution demonstrates the use of `defusedxml` to securely parse XML data, protecting against XXE attacks."
                },
                {
                  "code": "import lxml.etree as etree\n\n# Safe XML parsing with lxml\nparser = etree.XMLParser(resolve_entities=False)\nxml_data = request.data\nroot = etree.fromstring(xml_data, parser)",
                  "description": "This example shows how to safely parse XML data using `lxml` by disabling external entity resolution, mitigating the risk of XXE attacks."
                }
              ]
            },
            "rationale": "XML External Entity (XXE) vulnerabilities can lead to severe security issues, including data leakage, denial of service, and SSRF attacks. By disabling external entity processing and using secure XML parsing libraries, developers can protect their applications from these critical vulnerabilities."
          },
          {
            "id": "python13",
            "title": "A Secure Password Should Be Used When Connecting to a Database",
            "description": "Detects instances where a database connection is made without a secure password. Using an empty or default password for database access introduces a significant security vulnerability, allowing unauthorized users to access and manipulate sensitive data.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "database", "password", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-798: Use of Hard-coded Credentials",
            "examples": {
              "positive": [
                {
                  "code": "import mysql.connector\n\n# Secure connection with a password\nconn = mysql.connector.connect(\n    host='localhost',\n    user='admin',\n    password=os.getenv('DB_PASSWORD'),\n    database='mydatabase'\n)",
                  "description": "This compliant code example connects to a MySQL database using a secure password retrieved from an environment variable, ensuring that the password is not hard-coded or empty."
                },
                {
                  "code": "import psycopg2\n\n# Secure connection with a password\nconn = psycopg2.connect(\n    dbname='mydatabase',\n    user='admin',\n    password=os.getenv('DB_PASSWORD'),\n    host='localhost'\n)",
                  "description": "This example demonstrates a secure PostgreSQL connection using a password stored in an environment variable, preventing unauthorized access."
                }
              ],
              "negative": [
                {
                  "code": "import mysql.connector\n\n# Insecure connection with an empty password\nconn = mysql.connector.connect(\n    host='localhost',\n    user='admin',\n    password='',\n    database='mydatabase'\n)  # Noncompliant",
                  "description": "This noncompliant code example connects to a MySQL database with an empty password, making it vulnerable to unauthorized access.",
                  "pattern": "mysql\\.connector\\.connect\\(.*password=['\"]{2}"
                },
                {
                  "code": "import psycopg2\n\n# Insecure connection with a hardcoded password\nconn = psycopg2.connect(\n    dbname='mydatabase',\n    user='admin',\n    password='password123',\n    host='localhost'\n)  # Noncompliant",
                  "description": "This example demonstrates a vulnerability where a PostgreSQL connection is made using a hardcoded password, which can be easily compromised.",
                  "pattern": "psycopg2\\.connect\\(.*password=['\"][^'\"]+['\"]"
                }
              ]
            },
            "fix": {
              "steps": [
                "Ensure that a strong, non-empty password is used when connecting to any database.",
                "Avoid hardcoding passwords in the source code. Instead, retrieve passwords from secure sources such as environment variables or a secure vault.",
                "Use encryption to store and transmit database credentials securely.",
                "Regularly rotate database passwords and enforce password policies that require complexity, length, and expiration.",
                "Ensure that default database credentials are changed immediately upon deployment to prevent unauthorized access."
              ],
              "examples": [
                {
                  "code": "import mysql.connector\n\n# Compliant connection using an environment variable for the password\nconn = mysql.connector.connect(\n    host='localhost',\n    user='admin',\n    password=os.getenv('DB_PASSWORD'),\n    database='mydatabase'\n)",
                  "description": "This compliant solution connects to a MySQL database using a secure password stored in an environment variable, avoiding the use of an empty or hardcoded password."
                },
                {
                  "code": "import psycopg2\n\n# Secure PostgreSQL connection with a password\nconn = psycopg2.connect(\n    dbname='mydatabase',\n    user='admin',\n    password=os.getenv('DB_PASSWORD'),\n    host='localhost'\n)",
                  "description": "This example demonstrates a secure connection to a PostgreSQL database using a password stored securely in an environment variable."
                }
              ]
            },
            "rationale": "Using an empty or default password when connecting to a database poses a significant security risk, enabling unauthorized access to sensitive data. By enforcing the use of strong, secure passwords and avoiding hardcoding credentials in the source code, developers can protect databases from unauthorized access and potential breaches."
          },
          {
            "id": "python14",
            "title": "XPath Queries Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where an XPath query is constructed using untrusted data without proper sanitization, making it vulnerable to injection attacks. XPath injections occur when user input is directly inserted into an XPath query without validation, allowing attackers to manipulate the query and access unauthorized XML data.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "xpath", "injection", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')",
            "examples": {
              "positive": [
                {
                  "code": "import lxml.etree as ET\n\n# Secure XPath query using parameterized inputs\nquery = \"/users/user[username=$username and password=$password]\"\nresult = root.xpath(query, username=secure_username, password=secure_password)",
                  "description": "This compliant code example constructs an XPath query using parameterized inputs, preventing user-controlled data from being directly injected into the query, which mitigates the risk of XPath injection."
                },
                {
                  "code": "import xml.etree.ElementTree as ET\n\n# Secure XPath query with input sanitization\nusername = sanitize_input(user_input_username)\npassword = sanitize_input(user_input_password)\nquery = f\"/users/user[username='{username}' and password='{password}']\"\nresult = root.findall(query)",
                  "description": "This example demonstrates a secure approach where user inputs are sanitized before being inserted into an XPath query, reducing the likelihood of injection attacks."
                }
              ],
              "negative": [
                {
                  "code": "import lxml.etree as ET\n\n# Insecure XPath query with unsanitized user input\nquery = f\"/users/user[username='{user_input_username}' and password='{user_input_password}']\"\nresult = root.xpath(query)  # Noncompliant",
                  "description": "This noncompliant code example constructs an XPath query by directly inserting user-controlled data without sanitization, making it vulnerable to XPath injection attacks.",
                  "pattern": "xpath\\(f?['\"].*\\{.*\\}['\"]"
                },
                {
                  "code": "import xml.etree.ElementTree as ET\n\n# Insecure XPath query with raw user input\nquery = \"/users/user[username='\" + user_input_username + \"' and password='\" + user_input_password + \"']\"\nresult = root.findall(query)  # Noncompliant",
                  "description": "This example demonstrates a vulnerability where user input is concatenated into an XPath query string without any sanitization or validation, exposing the application to XPath injection.",
                  "pattern": "findall\\(['\"].*['\"]\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Use parameterized queries to construct XPath expressions instead of directly injecting user input.",
                "Sanitize and validate all user inputs before using them in an XPath query to ensure they do not contain malicious code.",
                "Avoid concatenating or directly inserting user input into XPath queries.",
                "Regularly review and test XPath query handling in your application to identify potential vulnerabilities.",
                "Use security libraries or frameworks that provide safe mechanisms for constructing XPath queries."
              ],
              "examples": [
                {
                  "code": "import lxml.etree as ET\n\n# Compliant XPath query using parameterized inputs\nquery = \"/users/user[username=$username and password=$password]\"\nresult = root.xpath(query, username=secure_username, password=secure_password)",
                  "description": "This compliant solution constructs an XPath query using secure parameterized inputs, avoiding the risks associated with directly injecting user-controlled data into the query."
                },
                {
                  "code": "import xml.etree.ElementTree as ET\n\n# Secure XPath query with sanitized input\nusername = sanitize_input(user_input_username)\npassword = sanitize_input(user_input_password)\nquery = f\"/users/user[username='{username}' and password='{password}']\"\nresult = root.findall(query)",
                  "description": "This example demonstrates a secure approach where user input is sanitized and validated before being used in an XPath query, reducing the risk of injection."
                }
              ]
            },
            "rationale": "XPath injection vulnerabilities arise when user-controlled data is directly injected into XPath queries without proper sanitization or parameterization. This can allow attackers to manipulate the query and access or modify unauthorized XML data. By enforcing the use of parameterized queries and input sanitization, developers can protect applications from such injection attacks, ensuring the security and integrity of the XML data being queried."
          },
          {
            "id": "python15",
            "title": "I/O Function Calls Should Not Be Vulnerable to Path Injection Attacks",
            "description": "Detects instances where file I/O operations are performed using untrusted data to construct file paths without proper validation or sanitization, making them vulnerable to path injection attacks. Path injections occur when user input is used to modify a file path, potentially leading to unauthorized file access or modification.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "path", "injection", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
            "examples": {
              "positive": [
                {
                  "code": "import os\n\n# Secure file access with input validation\nfilename = os.path.basename(user_input_filename)\nfilepath = os.path.join('/secure_directory', filename)\nwith open(filepath, 'r') as file:\n    data = file.read()",
                  "description": "This compliant code example ensures that only the basename of the user input is used to construct the file path, preventing path traversal attacks."
                },
                {
                  "code": "import os\n\n# Secure file access with path sanitization\nsafe_filename = sanitize_filename(user_input_filename)\nfilepath = os.path.join('/secure_directory', safe_filename)\nwith open(filepath, 'r') as file:\n    data = file.read()",
                  "description": "This example demonstrates a secure approach where the user input is sanitized before being used in the file path, reducing the likelihood of path injection attacks."
                }
              ],
              "negative": [
                {
                  "code": "import os\n\n# Insecure file access with unsanitized user input\nfilepath = os.path.join('/secure_directory', user_input_filename)\nwith open(filepath, 'r') as file:\n    data = file.read()  # Noncompliant",
                  "description": "This noncompliant code example constructs a file path using untrusted user input without sanitization, making it vulnerable to path injection attacks.",
                  "pattern": "open\\(os\\.path\\.join\\(['\"].*['\"],.*\\)"
                },
                {
                  "code": "import os\n\n# Insecure file access with direct user input\nwith open('/secure_directory/' + user_input_filename, 'r') as file:\n    data = file.read()  # Noncompliant",
                  "description": "This example demonstrates a vulnerability where user input is directly concatenated into a file path string without validation or sanitization, exposing the application to path injection.",
                  "pattern": "open\\(['\"].*['\"]\\+.*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always validate and sanitize user input before using it to construct file paths.",
                "Use secure methods like `os.path.basename` to strip dangerous components from user input.",
                "Avoid directly concatenating user input into file paths.",
                "Limit file access to specific directories and ensure that user input cannot escape these directories.",
                "Use libraries or frameworks that provide safe mechanisms for handling file paths."
              ],
              "examples": [
                {
                  "code": "import os\n\n# Compliant file access using validated input\nfilename = os.path.basename(user_input_filename)\nfilepath = os.path.join('/secure_directory', filename)\nwith open(filepath, 'r') as file:\n    data = file.read()",
                  "description": "This compliant solution ensures that only the filename is used in constructing the file path, mitigating the risk of path injection."
                },
                {
                  "code": "import os\n\n# Secure file access with sanitized input\nsafe_filename = sanitize_filename(user_input_filename)\nfilepath = os.path.join('/secure_directory', safe_filename)\nwith open(filepath, 'r') as file:\n    data = file.read()",
                  "description": "This example demonstrates a secure approach where the filename is sanitized before being used in the file path, preventing path traversal."
                }
              ]
            },
            "rationale": "Path injection vulnerabilities occur when user-controlled input is used to construct file paths without proper validation or sanitization. This can allow attackers to manipulate file paths to access, modify, or delete unauthorized files. By enforcing strict validation and sanitization of file paths, developers can protect applications from these attacks, ensuring that file operations are performed safely and securely."
          },
          {
            "id": "python16",
            "title": "LDAP Queries Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where an LDAP query is constructed using untrusted data without proper sanitization or escaping, making it vulnerable to injection attacks. LDAP injections occur when user input is directly inserted into an LDAP query without validation, allowing attackers to manipulate the query and execute malicious LDAP commands.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "ldap", "injection", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')",
            "examples": {
              "positive": [
                {
                  "code": "import ldap\n\n# Secure LDAP query using parameterized search filters\ncon = ldap.initialize('ldap://localhost')\nusername = ldap.filter.escape_filter_chars(user_input_username)\nquery = f'(uid={username})'\nresult = con.search_s('ou=users,dc=example,dc=com', ldap.SCOPE_SUBTREE, query)",
                  "description": "This compliant code example ensures that user input is properly escaped before being used in an LDAP query, preventing LDAP injection attacks."
                },
                {
                  "code": "import ldap\n\n# Secure LDAP query with input validation\nusername = validate_username(user_input_username)\nquery = f'(uid={username})'\nresult = con.search_s('ou=users,dc=example,dc=com', ldap.SCOPE_SUBTREE, query)",
                  "description": "This example demonstrates a secure approach where user input is validated before being used in an LDAP query, reducing the likelihood of LDAP injection."
                }
              ],
              "negative": [
                {
                  "code": "import ldap\n\n# Insecure LDAP query with unsanitized user input\ncon = ldap.initialize('ldap://localhost')\nquery = f'(uid={user_input_username})'\nresult = con.search_s('ou=users,dc=example,dc=com', ldap.SCOPE_SUBTREE, query)  # Noncompliant",
                  "description": "This noncompliant code example constructs an LDAP query by directly inserting user-controlled data without sanitization or escaping, making it vulnerable to LDAP injection attacks.",
                  "pattern": "search_s\\(['\"].*['\"],.*\\(uid=.*\\)"
                },
                {
                  "code": "import ldap\n\n# Insecure LDAP query with direct user input\nquery = '(uid=' + user_input_username + ')'\nresult = con.search_s('ou=users,dc=example,dc=com', ldap.SCOPE_SUBTREE, query)  # Noncompliant",
                  "description": "This example demonstrates a vulnerability where user input is directly concatenated into an LDAP query string without validation or sanitization, exposing the application to LDAP injection.",
                  "pattern": "search_s\\(['\"].*['\"]\\+.*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always escape special characters in user input before using it in LDAP queries.",
                "Use safe libraries or functions, like `ldap.filter.escape_filter_chars`, to properly escape or sanitize user input.",
                "Avoid directly concatenating user input into LDAP query strings.",
                "Perform strict validation on user input to ensure it meets the expected format before including it in LDAP queries.",
                "Use parameterized queries where possible to separate user input from the query logic."
              ],
              "examples": [
                {
                  "code": "import ldap\n\n# Compliant LDAP query using escaped input\ncon = ldap.initialize('ldap://localhost')\nusername = ldap.filter.escape_filter_chars(user_input_username)\nquery = f'(uid={username})'\nresult = con.search_s('ou=users,dc=example,dc=com', ldap.SCOPE_SUBTREE, query)",
                  "description": "This compliant solution escapes special characters in user input before using it in an LDAP query, mitigating the risk of LDAP injection."
                },
                {
                  "code": "import ldap\n\n# Secure LDAP query with input validation\nusername = validate_username(user_input_username)\nquery = f'(uid={username})'\nresult = con.search_s('ou=users,dc=example,dc=com', ldap.SCOPE_SUBTREE, query)",
                  "description": "This example demonstrates a secure approach where user input is validated before being used in an LDAP query, preventing LDAP injection."
                }
              ]
            },
            "rationale": "LDAP injection vulnerabilities occur when user-controlled input is directly inserted into LDAP queries without proper sanitization or escaping. This allows attackers to manipulate the query, potentially leading to unauthorized access, data leakage, or privilege escalation. By enforcing input validation and escaping, developers can protect LDAP queries from injection attacks, ensuring the security and integrity of the LDAP operations."
          },
          {
            "id": "python17",
            "title": "OS Commands Should Not Be Vulnerable to Command Injection Attacks",
            "description": "Detects instances where OS commands are constructed using untrusted data without proper sanitization or escaping, making them vulnerable to command injection attacks. OS command injections occur when user input is used to build command lines that are then executed by the system shell, allowing attackers to execute arbitrary commands on the underlying operating system.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "os", "command", "injection", "cwe", "python3"],
            "severity": "Blocker",
            "cwe": "CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')",
            "examples": {
              "positive": [
                {
                  "code": "import subprocess\n\n# Secure command execution using a list of arguments\nsubprocess.run(['ls', '-l', '/var/log'])",
                  "description": "This compliant code example uses a list of arguments for command execution, which mitigates the risk of command injection by avoiding the use of a shell."
                },
                {
                  "code": "import subprocess\n\n# Secure command execution with input validation\ncommand = 'ls'\npath = sanitize_input(user_input_path)\nsubprocess.run([command, '-l', path])",
                  "description": "This example demonstrates a secure approach where user input is sanitized before being used in a command, reducing the likelihood of command injection."
                }
              ],
              "negative": [
                {
                  "code": "import os\n\n# Insecure command execution with unsanitized user input\nos.system(f'ls -l {user_input_path}')  # Noncompliant",
                  "description": "This noncompliant code example constructs a command string using untrusted user input without sanitization, making it vulnerable to command injection attacks.",
                  "pattern": "os\\.system\\(f?['\"].*\\{.*\\}['\"]"
                },
                {
                  "code": "import subprocess\n\n# Insecure command execution with direct user input\ncommand = f'ls -l {user_input_path}'\nsubprocess.run(command, shell=True)  # Noncompliant",
                  "description": "This example demonstrates a vulnerability where user input is directly concatenated into a command string and executed with a shell, exposing the application to command injection.",
                  "pattern": "subprocess\\.run\\(f?['\"].*\\{.*\\}['\"], shell=True\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Avoid using shell=True in subprocess functions when executing commands with user input.",
                "Use a list of arguments for command execution instead of constructing command strings.",
                "Always validate and sanitize user input before using it in command-line operations.",
                "Consider using high-level libraries that abstract OS command execution and mitigate injection risks.",
                "Regularly review and test code that interacts with the operating system to identify and fix potential injection points."
              ],
              "examples": [
                {
                  "code": "import subprocess\n\n# Compliant command execution using a list of arguments\nsubprocess.run(['ls', '-l', '/var/log'])",
                  "description": "This compliant solution uses a list of arguments to execute a command, avoiding the risks associated with using a shell and constructing command strings with user input."
                },
                {
                  "code": "import subprocess\n\n# Secure command execution with sanitized input\ncommand = 'ls'\npath = sanitize_input(user_input_path)\nsubprocess.run([command, '-l', path])",
                  "description": "This example demonstrates a secure approach where user input is sanitized before being used in a command, mitigating the risk of command injection."
                }
              ]
            },
            "rationale": "OS command injection vulnerabilities occur when user-controlled input is used to construct command strings that are executed by the system shell without proper sanitization or escaping. This allows attackers to execute arbitrary commands on the operating system, potentially leading to data leakage, privilege escalation, or denial of service. By enforcing input validation, avoiding shell usage, and using argument lists, developers can protect applications from command injection attacks."
          },
          {
            "id": "python18",
            "title": "GraphQL Queries Should Not Be Vulnerable to Denial of Service Attacks",
            "description": "Detects instances where a GraphQL server fails to limit the depth of queries, making it vulnerable to Denial of Service (DoS) attacks. GraphQL servers can be exploited by attackers who craft deeply nested queries that consume excessive server resources, potentially leading to server instability or failure.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "graphql", "dos", "injection", "cwe", "python3"],
            "severity": "Critical",
            "cwe": "CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')",
            "examples": {
              "positive": [
                {
                  "code": "from graphql import GraphQLObjectType, GraphQLSchema\nfrom graphql.depth_analysis import DepthAnalysis\n\n# Secure schema definition with query depth limitation\nschema = GraphQLSchema(query=QueryRootType)\nmax_depth = 5\nquery = '{ user { id name } }'\ndepth_analysis = DepthAnalysis(max_depth=max_depth)\ndepth_analysis.analyze(query)\nif depth_analysis.is_valid():\n    result = schema.execute(query)\nelse:\n    raise ValueError('Query depth exceeds the maximum allowed depth')",
                  "description": "This compliant code example demonstrates how to limit the depth of a GraphQL query to mitigate the risk of DoS attacks. The query is analyzed before execution to ensure it does not exceed the maximum allowed depth."
                },
                {
                  "code": "from graphql import GraphQLObjectType, GraphQLSchema\nfrom graphql.depth_limit import depth_limit_rule\nfrom graphql.validation import validate\n\n# Secure schema with query depth validation\nschema = GraphQLSchema(query=QueryRootType)\nvalidation_rules = [depth_limit_rule(max_depth=5)]\nquery = '{ user { id name } }'\nerrors = validate(schema, query, rules=validation_rules)\nif not errors:\n    result = schema.execute(query)\nelse:\n    raise ValueError('Query depth exceeds the maximum allowed depth')",
                  "description": "This example shows a secure approach to validating a GraphQL query's depth before execution. The use of validation rules ensures that queries do not exceed the specified depth, preventing resource exhaustion."
                }
              ],
              "negative": [
                {
                  "code": "from graphql import GraphQLObjectType, GraphQLSchema\n\n# Insecure schema without query depth limitation\nschema = GraphQLSchema(query=QueryRootType)\nquery = '{ user { id name friends { id name friends { id name } } } }'\nresult = schema.execute(query)  # Noncompliant",
                  "description": "This noncompliant code example demonstrates a GraphQL schema execution without any depth limitation, making it vulnerable to DoS attacks via deeply nested queries.",
                  "pattern": "schema\\.execute\\(.*\\)"
                },
                {
                  "code": "from graphql import GraphQLObjectType, GraphQLSchema\n\n# Insecure schema with direct query execution\nschema = GraphQLSchema(query=QueryRootType)\nquery = user_input_query\nresult = schema.execute(query)  # Noncompliant",
                  "description": "This example shows a vulnerability where a GraphQL query is executed directly without checking its depth, allowing attackers to craft queries that can exhaust server resources.",
                  "pattern": "schema\\.execute\\(.*user_input_query.*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Implement a query depth limit to prevent deeply nested queries from exhausting server resources.",
                "Use tools or libraries that provide depth analysis or validation for GraphQL queries.",
                "Always validate the depth of GraphQL queries before executing them.",
                "Monitor and log query patterns to detect potential DoS attempts.",
                "Consider implementing rate limiting and other protective measures to reduce the impact of potential DoS attacks."
              ],
              "examples": [
                {
                  "code": "from graphql import GraphQLObjectType, GraphQLSchema\nfrom graphql.depth_limit import depth_limit_rule\nfrom graphql.validation import validate\n\n# Compliant query depth validation\nschema = GraphQLSchema(query=QueryRootType)\nvalidation_rules = [depth_limit_rule(max_depth=5)]\nquery = '{ user { id name } }'\nerrors = validate(schema, query, rules=validation_rules)\nif not errors:\n    result = schema.execute(query)\nelse:\n    raise ValueError('Query depth exceeds the maximum allowed depth')",
                  "description": "This compliant solution shows how to validate the depth of a GraphQL query before execution, mitigating the risk of DoS attacks."
                },
                {
                  "code": "from graphql import GraphQLObjectType, GraphQLSchema\nfrom graphql.depth_analysis import DepthAnalysis\n\n# Secure schema with query depth analysis\nschema = GraphQLSchema(query=QueryRootType)\nmax_depth = 5\nquery = '{ user { id name } }'\ndepth_analysis = DepthAnalysis(max_depth=max_depth)\ndepth_analysis.analyze(query)\nif depth_analysis.is_valid():\n    result = schema.execute(query)\nelse:\n    raise ValueError('Query depth exceeds the maximum allowed depth')",
                  "description": "This example demonstrates a secure method for limiting the depth of GraphQL queries, preventing resource exhaustion and ensuring the stability of the server."
                }
              ]
            },
            "rationale": "GraphQL servers are vulnerable to Denial of Service (DoS) attacks when they fail to limit the depth of queries. Such attacks can exhaust server resources, leading to server instability or failure. By enforcing query depth limits and validating queries before execution, developers can protect GraphQL servers from DoS attacks, ensuring the availability and reliability of the application."
          },
          {
            "id": "python19",
            "title": "AWS IAM Policies Should Limit the Scope of Permissions Given",
            "description": "Detects instances where AWS IAM identity-based policies grant overly broad permissions, making them vulnerable to privilege escalation attacks. Identity policies that grant more privileges than necessary can enable users or roles to perform unauthorized actions, potentially leading to security breaches and unauthorized access to sensitive resources.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "aws", "iam", "permissions", "cwe", "python3"],
            "severity": "Critical",
            "cwe": "CWE-266: Incorrect Privilege Assignment",
            "examples": {
              "positive": [
                {
                  "code": "import boto3\n\n# Secure IAM policy with restricted permissions\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:GetObject\",\n                \"s3:ListBucket\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::example-bucket\",\n                \"arn:aws:s3:::example-bucket/*\"\n            ]\n        }\n    ]\n}\niam = boto3.client('iam')\nresponse = iam.create_policy(\n    PolicyName='MyRestrictedPolicy',\n    PolicyDocument=json.dumps(policy)\n)",
                  "description": "This compliant code example creates an IAM policy with specific, limited permissions, reducing the risk of privilege escalation by ensuring that users can only access the resources they need."
                },
                {
                  "code": "import boto3\n\n# Secure IAM role creation with least privilege policy\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ec2:DescribeInstances\",\n                \"s3:GetObject\"\n            ],\n            \"Resource\": [\n                \"arn:aws:ec2:region:account-id:instance/*\",\n                \"arn:aws:s3:::specific-bucket/specific-object\"\n            ]\n        }\n    ]\n}\niam = boto3.client('iam')\nresponse = iam.create_role(\n    RoleName='MyLeastPrivilegeRole',\n    AssumeRolePolicyDocument=json.dumps(policy)\n)",
                  "description": "This example demonstrates the creation of an IAM role with a policy that adheres to the principle of least privilege, allowing access only to necessary actions and resources."
                }
              ],
              "negative": [
                {
                  "code": "import boto3\n\n# Insecure IAM policy with overly broad permissions\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:*\",\n            \"Resource\": \"*\"\n        }\n    ]\n}\niam = boto3.client('iam')\nresponse = iam.create_policy(\n    PolicyName='MyOverlyBroadPolicy',\n    PolicyDocument=json.dumps(policy)\n)  # Noncompliant",
                  "description": "This noncompliant code example creates an IAM policy with overly broad permissions, allowing access to all S3 actions and resources, which can lead to privilege escalation and security risks.",
                  "pattern": "\"Action\": \"\\*\""
                },
                {
                  "code": "import boto3\n\n# Insecure IAM policy with wildcard resource\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"ec2:DescribeInstances\",\n            \"Resource\": \"*\"\n        }\n    ]\n}\niam = boto3.client('iam')\nresponse = iam.create_policy(\n    PolicyName='MyInsecurePolicy',\n    PolicyDocument=json.dumps(policy)\n)  # Noncompliant",
                  "description": "This example shows a vulnerability where an IAM policy grants access to all resources using a wildcard, which can be exploited to access unintended resources.",
                  "pattern": "\"Resource\": \"\\*\""
                }
              ]
            },
            "fix": {
              "steps": [
                "Ensure IAM policies grant only the minimum necessary permissions to users, groups, or roles.",
                "Avoid using wildcards (*) in IAM policies for both actions and resources.",
                "Review and audit IAM policies regularly to identify and tighten overly broad permissions.",
                "Use specific ARNs to define the resources to which permissions apply, rather than using wildcards.",
                "Implement the principle of least privilege by restricting permissions to only those necessary for the specific role or user."
              ],
              "examples": [
                {
                  "code": "import boto3\n\n# Compliant IAM policy with specific permissions and resources\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"ec2:DescribeInstances\",\n            \"Resource\": \"arn:aws:ec2:region:account-id:instance/*\"\n        }\n    ]\n}\niam = boto3.client('iam')\nresponse = iam.create_policy(\n    PolicyName='MyRestrictedPolicy',\n    PolicyDocument=json.dumps(policy)\n)",
                  "description": "This compliant solution shows an IAM policy that limits permissions to specific actions and resources, adhering to the principle of least privilege and mitigating the risk of privilege escalation."
                },
                {
                  "code": "import boto3\n\n# Secure IAM role with minimal permissions\npolicy = {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::specific-bucket/specific-object\"\n        }\n    ]\n}\niam = boto3.client('iam')\nresponse = iam.create_role(\n    RoleName='MySecureRole',\n    AssumeRolePolicyDocument=json.dumps(policy)\n)",
                  "description": "This example demonstrates a secure IAM role with specific, limited permissions, reducing the risk of unauthorized access and privilege escalation."
                }
              ]
            },
            "rationale": "AWS IAM policies that grant overly broad permissions can lead to privilege escalation and unauthorized access to critical resources. By enforcing the principle of least privilege and avoiding the use of wildcards, developers can create more secure IAM policies that minimize the risk of security breaches and unauthorized actions."
          },
          {
            "id": "python20",
            "title": "JWT Should Be Signed and Verified",
            "description": "Detects instances where JSON Web Tokens (JWTs) are not properly signed or verified, making them vulnerable to forgery and impersonation attacks. JWTs must be signed with a robust cipher algorithm, and the signature must be verified to ensure the integrity and authenticity of the token. Without proper signing and verification, attackers can craft fraudulent tokens to impersonate users and gain unauthorized access.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "jwt", "token", "cwe", "python3"],
            "severity": "Critical",
            "cwe": "CWE-347: Improper Verification of Cryptographic Signature",
            "examples": {
              "positive": [
                {
                  "code": "import jwt\n\n# Securely sign and verify a JWT\nsecret_key = 'your-256-bit-secret'\nencoded_jwt = jwt.encode({'user_id': 123}, secret_key, algorithm='HS256')\ndecoded_jwt = jwt.decode(encoded_jwt, secret_key, algorithms=['HS256'])",
                  "description": "This compliant code example demonstrates how to securely sign and verify a JWT using a strong cipher algorithm (HS256). The token is signed with a secret key, and the signature is verified upon decoding."
                },
                {
                  "code": "import jwt\n\n# Securely sign and verify a JWT with RSA\nprivate_key = open('private.pem').read()\npublic_key = open('public.pem').read()\nencoded_jwt = jwt.encode({'user_id': 123}, private_key, algorithm='RS256')\ndecoded_jwt = jwt.decode(encoded_jwt, public_key, algorithms=['RS256'])",
                  "description": "This example demonstrates secure JWT signing and verification using RSA. The token is signed with a private key and verified with a corresponding public key, ensuring the token's integrity and authenticity."
                }
              ],
              "negative": [
                {
                  "code": "import jwt\n\n# Insecure JWT usage without signing\npayload = {'user_id': 123}\nencoded_jwt = jwt.encode(payload, '', algorithm=None)  # Noncompliant",
                  "description": "This noncompliant code example demonstrates the creation of a JWT without signing. The token is not protected by any signature, making it vulnerable to forgery and impersonation attacks.",
                  "pattern": "jwt\\.encode\\(.*algorithm=None\\)"
                },
                {
                  "code": "import jwt\n\n# Insecure JWT usage with weak signature algorithm\nsecret_key = 'your-256-bit-secret'\nencoded_jwt = jwt.encode({'user_id': 123}, secret_key, algorithm='none')\ndecoded_jwt = jwt.decode(encoded_jwt, secret_key, algorithms=['none'])  # Noncompliant",
                  "description": "This example shows a vulnerability where a JWT is signed with a weak or nonexistent algorithm ('none'). This makes the token susceptible to forgery as it lacks a proper cryptographic signature.",
                  "pattern": "jwt\\.encode\\(.*algorithm=['\"]none['\"]\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Ensure that all JWTs are signed with a robust cryptographic algorithm, such as HS256 or RS256.",
                "Verify the signature of JWTs before using the information they contain to ensure the token's integrity and authenticity.",
                "Avoid using 'none' as the algorithm when signing JWTs, as this disables the signature, making the token vulnerable to forgery.",
                "Use libraries or tools that enforce proper JWT signing and verification practices.",
                "Regularly review and audit JWT implementation in your application to identify and address potential security risks."
              ],
              "examples": [
                {
                  "code": "import jwt\n\n# Compliant JWT signing and verification with HS256\nsecret_key = 'your-256-bit-secret'\nencoded_jwt = jwt.encode({'user_id': 123}, secret_key, algorithm='HS256')\ndecoded_jwt = jwt.decode(encoded_jwt, secret_key, algorithms=['HS256'])",
                  "description": "This compliant solution shows how to sign and verify a JWT using HS256, ensuring the token's integrity and preventing forgery."
                },
                {
                  "code": "import jwt\n\n# Secure JWT signing and verification with RS256\nprivate_key = open('private.pem').read()\npublic_key = open('public.pem').read()\nencoded_jwt = jwt.encode({'user_id': 123}, private_key, algorithm='RS256')\ndecoded_jwt = jwt.decode(encoded_jwt, public_key, algorithms=['RS256'])",
                  "description": "This example demonstrates secure JWT signing and verification using RSA, which provides strong cryptographic assurance of the token's authenticity."
                }
              ]
            },
            "rationale": "JWTs that are not properly signed or verified are vulnerable to forgery, allowing attackers to impersonate users and gain unauthorized access. By enforcing robust signing and verification practices, developers can protect the integrity and authenticity of JWTs, ensuring secure communication and data privacy."
          },
          {
            "id": "python21",
            "title": "Cipher Algorithms Should Be Robust",
            "description": "Detects instances where weak or deprecated cipher algorithms are used for encryption, making the encrypted data vulnerable to being decrypted by attackers without prior knowledge of the key. Encryption should be performed using strong, modern algorithms to ensure the confidentiality and integrity of sensitive information.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "encryption", "cipher", "cwe", "privacy", "python3"],
            "severity": "Critical",
            "cwe": "CWE-326: Inadequate Encryption Strength",
            "examples": {
              "positive": [
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Secure encryption using AES\nkey = b'sixteen byte key'\niv = b'sixteen byte iv '\ncipher = Cipher(algorithms.AES(key), modes.CFB(iv))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(b'my secret data') + encryptor.finalize()",
                  "description": "This compliant code example demonstrates how to securely encrypt data using the AES algorithm, which is considered strong and reliable for encryption."
                },
                {
                  "code": "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Secure encryption using AES with a key derived from a password\npassword = b'my_password'\nsalt = b'my_salt'\nkdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100000)\nkey = kdf.derive(password)\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(b'my secret data') + encryptor.finalize()",
                  "description": "This example demonstrates secure encryption using AES with a key derived from a password, ensuring that the data is encrypted with a strong and reliable algorithm."
                }
              ],
              "negative": [
                {
                  "code": "from Crypto.Cipher import DES\n\n# Insecure encryption using DES\nkey = b'8bytekey'\ncipher = DES.new(key, DES.MODE_CBC)\nciphertext = cipher.encrypt(b'my secret data')  # Noncompliant",
                  "description": "This noncompliant code example uses DES, a deprecated and insecure encryption algorithm, making the encrypted data vulnerable to being decrypted by attackers.",
                  "pattern": "DES\\.new\\("
                },
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Insecure encryption using 3DES\nkey = b'24bytekeyfor3des'\ncipher = Cipher(algorithms.TripleDES(key), modes.CBC(iv))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(b'my secret data') + encryptor.finalize()  # Noncompliant",
                  "description": "This example shows a vulnerability where the 3DES algorithm is used for encryption, which is no longer considered secure and should be avoided in favor of stronger algorithms like AES.",
                  "pattern": "TripleDES\\("
                }
              ]
            },
            "fix": {
              "steps": [
                "Use strong and modern encryption algorithms, such as AES, for encrypting sensitive data.",
                "Avoid using deprecated or weak algorithms like DES or 3DES, as they are vulnerable to attacks.",
                "Ensure that encryption keys are of adequate length and generated securely.",
                "Regularly review and update encryption practices to align with current security standards and best practices.",
                "Consider using well-established cryptographic libraries that enforce the use of strong algorithms."
              ],
              "examples": [
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Compliant encryption using AES\nkey = b'sixteen byte key'\niv = b'sixteen byte iv '\ncipher = Cipher(algorithms.AES(key), modes.CFB(iv))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(b'my secret data') + encryptor.finalize()",
                  "description": "This compliant solution demonstrates the use of the AES algorithm, which is widely regarded as secure for encryption, ensuring the confidentiality and integrity of the data."
                },
                {
                  "code": "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Secure encryption using AES with a derived key\npassword = b'my_password'\nsalt = b'my_salt'\nkdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100000)\nkey = kdf.derive(password)\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(b'my secret data') + encryptor.finalize()",
                  "description": "This example demonstrates secure encryption using AES with a key derived from a password, ensuring the data is protected by a strong encryption algorithm."
                }
              ]
            },
            "rationale": "Using weak or deprecated encryption algorithms can compromise the confidentiality and integrity of sensitive data. By enforcing the use of robust cipher algorithms, developers can protect encrypted data from being decrypted by attackers and ensure secure communication and storage."
          },
          {
            "id": "python22",
            "title": "Encryption Algorithms Should Be Used with Secure Mode and Padding Scheme",
            "description": "Detects instances where encryption algorithms are used with insecure modes or padding schemes, making the encrypted data vulnerable to attacks that can recover the plaintext or modify the ciphertext. It is critical to use secure modes and padding schemes to ensure the confidentiality and integrity of sensitive information.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "encryption", "mode", "padding", "cwe", "privacy", "python3"],
            "severity": "Critical",
            "cwe": "CWE-327: Use of a Broken or Risky Cryptographic Algorithm",
            "examples": {
              "positive": [
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Secure encryption using AES with GCM mode\nkey = b'sixteen byte key'\nnonce = b'sixteen byte nonce'\ncipher = Cipher(algorithms.AES(key), modes.GCM(nonce))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(b'my secret data') + encryptor.finalize()",
                  "description": "This compliant code example demonstrates how to securely encrypt data using the AES algorithm with GCM mode, which provides both encryption and authentication, ensuring data confidentiality and integrity."
                },
                {
                  "code": "from cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import hashes\n\n# Secure encryption using RSA with OAEP padding\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\nciphertext = public_key.encrypt(\n    b'my secret data',\n    padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None\n    )\n)",
                  "description": "This example demonstrates secure encryption using RSA with OAEP padding, which provides secure padding for RSA encryption and protects against certain cryptographic attacks."
                }
              ],
              "negative": [
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Insecure encryption using AES with ECB mode\nkey = b'sixteen byte key'\ncipher = Cipher(algorithms.AES(key), modes.ECB())\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(b'my secret data') + encryptor.finalize()  # Noncompliant",
                  "description": "This noncompliant code example uses AES with ECB mode, which is insecure because identical plaintext blocks are encrypted to the same ciphertext, making patterns in the data easily recognizable.",
                  "pattern": "modes\\.ECB\\(\\)"
                },
                {
                  "code": "from cryptography.hazmat.primitives.asymmetric import rsa, padding\n\n# Insecure encryption using RSA with PKCS1v1.5 padding\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\nciphertext = public_key.encrypt(\n    b'my secret data',\n    padding.PKCS1v15()\n)  # Noncompliant",
                  "description": "This example shows a vulnerability where RSA encryption is used with PKCS1v1.5 padding, which is susceptible to certain attacks and should be avoided in favor of more secure padding schemes like OAEP.",
                  "pattern": "padding\\.PKCS1v15\\(\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Use secure encryption modes such as GCM (Galois/Counter Mode) or CBC (Cipher Block Chaining) with authenticated encryption where applicable.",
                "Avoid using ECB (Electronic Codebook) mode, as it is insecure and can reveal patterns in the encrypted data.",
                "For RSA encryption, use OAEP (Optimal Asymmetric Encryption Padding) instead of PKCS1v1.5, as it provides better security.",
                "Ensure that appropriate padding schemes are used to prevent padding oracle attacks.",
                "Regularly review and update encryption practices to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Compliant encryption using AES with GCM mode\nkey = b'sixteen byte key'\nnonce = b'sixteen byte nonce'\ncipher = Cipher(algorithms.AES(key), modes.GCM(nonce))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(b'my secret data') + encryptor.finalize()",
                  "description": "This compliant solution demonstrates the use of AES with GCM mode, providing both encryption and authentication to ensure the confidentiality and integrity of the data."
                },
                {
                  "code": "from cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import hashes\n\n# Secure RSA encryption with OAEP padding\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\nciphertext = public_key.encrypt(\n    b'my secret data',\n    padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None\n    )\n)",
                  "description": "This example demonstrates secure RSA encryption using OAEP padding, which provides protection against several attacks that PKCS1v1.5 does not."
                }
              ]
            },
            "rationale": "Using insecure encryption modes or padding schemes can compromise the confidentiality and integrity of sensitive data. By enforcing the use of secure modes like GCM for AES and OAEP for RSA, developers can protect encrypted data from being recovered or modified by attackers, ensuring secure communication and storage."
          },
          {
            "id": "python23",
            "title": "Server Hostnames Should Be Verified During SSL/TLS Connections",
            "description": "Detects instances where SSL/TLS connections are made without verifying the server hostname, making them vulnerable to man-in-the-middle attacks where an attacker could impersonate a trusted host. Hostname verification ensures that the server's identity matches the certificate presented during the SSL/TLS handshake, preventing attackers from intercepting or manipulating sensitive data.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "ssl", "tls", "hostname", "cwe", "privacy", "python3"],
            "severity": "Critical",
            "cwe": "CWE-295: Improper Certificate Validation",
            "examples": {
              "positive": [
                {
                  "code": "import requests\n\n# Secure SSL/TLS connection with hostname verification\nresponse = requests.get('https://example.com', verify=True)\n",
                  "description": "This compliant code example demonstrates how to securely establish an SSL/TLS connection with the server's hostname verification enabled, ensuring that the server's identity is authenticated."
                },
                {
                  "code": "import ssl\nimport socket\n\n# Secure SSL/TLS connection with explicit hostname verification\nhostname = 'example.com'\ncontext = ssl.create_default_context()\nconn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\nconn.connect((hostname, 443))\nconn.do_handshake()\n",
                  "description": "This example demonstrates secure SSL/TLS connection setup with explicit hostname verification, ensuring that the server's certificate matches the expected hostname."
                }
              ],
              "negative": [
                {
                  "code": "import requests\n\n# Insecure SSL/TLS connection with disabled hostname verification\nresponse = requests.get('https://example.com', verify=False)  # Noncompliant",
                  "description": "This noncompliant code example disables SSL/TLS hostname verification by setting `verify=False`, making the connection vulnerable to man-in-the-middle attacks.",
                  "pattern": "requests\\.get\\(.*verify=False\\)"
                },
                {
                  "code": "import ssl\nimport socket\n\n# Insecure SSL/TLS connection without hostname verification\nhostname = 'example.com'\ncontext = ssl._create_unverified_context()\nconn = context.wrap_socket(socket.socket(socket.AF_INET))\nconn.connect((hostname, 443))\nconn.do_handshake()  # Noncompliant",
                  "description": "This example shows a vulnerability where an SSL/TLS connection is established without hostname verification by using `_create_unverified_context()`, making it susceptible to man-in-the-middle attacks.",
                  "pattern": "ssl\\._create_unverified_context\\(\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always enable hostname verification during SSL/TLS connections to ensure that the server's certificate matches the expected hostname.",
                "Avoid using `verify=False` in requests or `ssl._create_unverified_context()` as these disable critical security checks.",
                "Use the `server_hostname` parameter when wrapping sockets with SSL to explicitly set the expected hostname.",
                "Regularly review and update SSL/TLS connection practices to align with current security standards and best practices.",
                "Use well-established libraries that enforce proper SSL/TLS security practices."
              ],
              "examples": [
                {
                  "code": "import requests\n\n# Compliant SSL/TLS connection with hostname verification\nresponse = requests.get('https://example.com', verify=True)\n",
                  "description": "This compliant solution ensures that SSL/TLS connections are established with hostname verification, preventing man-in-the-middle attacks by validating the server's identity."
                },
                {
                  "code": "import ssl\nimport socket\n\n# Secure SSL/TLS connection with hostname verification\nhostname = 'example.com'\ncontext = ssl.create_default_context()\nconn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\nconn.connect((hostname, 443))\nconn.do_handshake()\n",
                  "description": "This example demonstrates a secure SSL/TLS connection setup with hostname verification, ensuring that the server's certificate matches the expected hostname."
                }
              ]
            },
            "rationale": "Disabling hostname verification during SSL/TLS connections can allow attackers to impersonate a trusted server, potentially intercepting or manipulating sensitive data. By enforcing hostname verification, developers can ensure that the server's identity is authenticated, protecting the integrity and privacy of the data being transmitted."
          },
          {
            "id": "python24",
            "title": "Insecure Temporary File Creation",
            "description": "Detects instances where temporary files are created in a non-atomic way, introducing race condition vulnerabilities. This can occur when file existence checks are performed separately from the actual file creation, allowing an attacker to create or manipulate the file before the application does, leading to potential security risks.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "temporary files", "race condition", "cwe", "python3"],
            "severity": "Critical",
            "cwe": "CWE-377: Insecure Temporary File",
            "examples": {
              "positive": [
                {
                  "code": "import tempfile\n\n# Secure temporary file creation using tempfile.NamedTemporaryFile\nwith tempfile.NamedTemporaryFile(delete=True) as tmp_file:\n    tmp_file.write(b'Secure content')\n",
                  "description": "This compliant code example demonstrates secure temporary file creation using `tempfile.NamedTemporaryFile`, which creates the file in a secure and atomic manner, preventing race conditions."
                },
                {
                  "code": "import os\nimport tempfile\n\n# Secure temporary file creation with proper permissions\nfd, path = tempfile.mkstemp()\nos.write(fd, b'Secure content')\nos.close(fd)\n",
                  "description": "This example shows a secure way of creating a temporary file using `tempfile.mkstemp`, which ensures the file is created securely and atomically, reducing the risk of race conditions."
                }
              ],
              "negative": [
                {
                  "code": "import os\n\n# Insecure temporary file creation with separate existence check\nif not os.path.exists('/tmp/insecure_temp_file'):\n    with open('/tmp/insecure_temp_file', 'w') as tmp_file:\n        tmp_file.write('Insecure content')  # Noncompliant",
                  "description": "This noncompliant code example performs an insecure temporary file creation by first checking if the file exists and then creating it, which can lead to race conditions where an attacker could create or manipulate the file before the application does.",
                  "pattern": "if not os\\.path\\.exists\\(.*\\)\\s*:\\s*with open\\(.*\\)"
                },
                {
                  "code": "import os\n\n# Insecure temporary file creation without using secure methods\nwith open('/tmp/insecure_temp_file', 'w') as tmp_file:\n    tmp_file.write('Insecure content')  # Noncompliant",
                  "description": "This example demonstrates an insecure way of creating a temporary file directly without using secure methods like `tempfile`, making it vulnerable to race conditions and potential exploitation by attackers.",
                  "pattern": "with open\\(.*\\,\\s*['\"]w['\"]\\s*\\)\\s*as\\s*.*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Use `tempfile` module functions like `NamedTemporaryFile` or `mkstemp` to create temporary files securely and atomically.",
                "Avoid performing separate existence checks before creating temporary files as this can introduce race conditions.",
                "Ensure that temporary files are created with appropriate permissions and are properly deleted after use.",
                "Regularly review file handling practices to ensure that temporary files are managed securely."
              ],
              "examples": [
                {
                  "code": "import tempfile\n\n# Compliant temporary file creation\nwith tempfile.NamedTemporaryFile(delete=True) as tmp_file:\n    tmp_file.write(b'Secure content')\n",
                  "description": "This compliant solution demonstrates secure temporary file creation using `tempfile.NamedTemporaryFile`, which creates the file in an atomic manner, preventing race conditions."
                },
                {
                  "code": "import os\nimport tempfile\n\n# Secure temporary file creation with proper permissions\nfd, path = tempfile.mkstemp()\nos.write(fd, b'Secure content')\nos.close(fd)\n",
                  "description": "This example shows a secure way of creating a temporary file using `tempfile.mkstemp`, ensuring that the file is created securely and atomically."
                }
              ]
            },
            "rationale": "Creating temporary files in a non-atomic way can expose the application to race conditions, allowing attackers to create or manipulate the file before the application does. By using secure methods for temporary file creation, developers can prevent such vulnerabilities and protect the application's integrity and security."
          },
          {
            "id": "python25",
            "title": "Server Certificates Should Be Verified During SSL/TLS Connections",
            "description": "Detects instances where SSL/TLS connections are made without verifying server certificates, making them vulnerable to man-in-the-middle attacks. Certificate validation is crucial for ensuring that the server's identity is authentic and that the communication is secure.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "ssl", "tls", "certificate", "cwe", "privacy", "python3"],
            "severity": "Critical",
            "cwe": "CWE-295: Improper Certificate Validation",
            "examples": {
              "positive": [
                {
                  "code": "import requests\n\n# Secure SSL/TLS connection with certificate validation\nresponse = requests.get('https://example.com', verify=True)\n",
                  "description": "This compliant code example demonstrates how to securely establish an SSL/TLS connection with server certificate validation enabled, ensuring that the server's identity is authenticated."
                },
                {
                  "code": "import ssl\nimport socket\n\n# Secure SSL/TLS connection with explicit certificate verification\nhostname = 'example.com'\ncontext = ssl.create_default_context()\nconn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\nconn.connect((hostname, 443))\nconn.do_handshake()\n",
                  "description": "This example shows how to securely establish an SSL/TLS connection with explicit server certificate verification, ensuring that the server's identity matches the expected certificate."
                }
              ],
              "negative": [
                {
                  "code": "import requests\n\n# Insecure SSL/TLS connection with certificate validation disabled\nresponse = requests.get('https://example.com', verify=False)  # Noncompliant",
                  "description": "This noncompliant code example disables server certificate validation by setting `verify=False`, making the connection vulnerable to man-in-the-middle attacks.",
                  "pattern": "requests\\.get\\(.*verify=False\\)"
                },
                {
                  "code": "import ssl\nimport socket\n\n# Insecure SSL/TLS connection without certificate verification\nhostname = 'example.com'\ncontext = ssl._create_unverified_context()\nconn = context.wrap_socket(socket.socket(socket.AF_INET))\nconn.connect((hostname, 443))\nconn.do_handshake()  # Noncompliant",
                  "description": "This example demonstrates an insecure SSL/TLS connection setup where certificate validation is disabled by using `_create_unverified_context()`, exposing the communication to potential man-in-the-middle attacks.",
                  "pattern": "ssl\\._create_unverified_context\\(\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always enable server certificate validation during SSL/TLS connections to ensure that the server's identity is authenticated.",
                "Avoid using `verify=False` in requests or `ssl._create_unverified_context()` as these disable critical security checks.",
                "Use trusted certificate authorities (CAs) and ensure that your application trusts only those CAs.",
                "Regularly review and update SSL/TLS connection practices to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "import requests\n\n# Compliant SSL/TLS connection with server certificate verification\nresponse = requests.get('https://example.com', verify=True)\n",
                  "description": "This compliant solution demonstrates how to securely establish an SSL/TLS connection with server certificate verification, protecting against man-in-the-middle attacks."
                },
                {
                  "code": "import ssl\nimport socket\n\n# Secure SSL/TLS connection with explicit certificate verification\nhostname = 'example.com'\ncontext = ssl.create_default_context()\nconn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)\nconn.connect((hostname, 443))\nconn.do_handshake()\n",
                  "description": "This example shows how to securely establish an SSL/TLS connection with server certificate verification, ensuring that the server's identity matches the expected certificate."
                }
              ]
            },
            "rationale": "Disabling server certificate validation during SSL/TLS connections can allow attackers to impersonate a trusted server, potentially intercepting or manipulating sensitive data. Enforcing certificate validation ensures that the server's identity is authenticated, protecting the integrity and privacy of the data being transmitted."
          },
          {
            "id": "python26",
            "title": "LDAP Connections Should Be Authenticated",
            "description": "Detects instances where LDAP connections are established without proper authentication, making them vulnerable to unauthorized access. Ensuring that LDAP connections are authenticated prevents unauthorized users from reading or modifying sensitive directory data.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "ldap", "authentication", "cwe", "privacy", "python3"],
            "severity": "Critical",
            "cwe": "CWE-306: Missing Authentication for Critical Function",
            "examples": {
              "positive": [
                {
                  "code": "import ldap3\n\n# Secure LDAP connection with simple bind authentication\nserver = ldap3.Server('ldap://example.com')\nconn = ldap3.Connection(server, user='cn=admin,dc=example,dc=com', password='secure_password', auto_bind=True)\n",
                  "description": "This compliant code example demonstrates how to establish an LDAP connection with proper simple bind authentication, ensuring that the connection is authenticated."
                },
                {
                  "code": "import ldap3\n\n# Secure LDAP connection using SASL authentication\nserver = ldap3.Server('ldap://example.com')\nconn = ldap3.Connection(server, authentication=ldap3.SASL, sasl_mechanism='GSSAPI', auto_bind=True)\n",
                  "description": "This example shows how to establish an LDAP connection using SASL authentication, ensuring secure and authenticated communication."
                }
              ],
              "negative": [
                {
                  "code": "import ldap3\n\n# Insecure LDAP connection with anonymous bind\nserver = ldap3.Server('ldap://example.com')\nconn = ldap3.Connection(server)\nconn.bind()  # Noncompliant",
                  "description": "This noncompliant code example establishes an LDAP connection without providing any credentials, leading to an anonymous bind which is insecure.",
                  "pattern": "ldap3\\.Connection\\(\\s*ldap3\\.Server\\(.*\\)\\s*\\)"
                },
                {
                  "code": "import ldap3\n\n# Insecure LDAP connection with unauthenticated authentication\nserver = ldap3.Server('ldap://example.com')\nconn = ldap3.Connection(server, user='', password='')\nconn.bind()  # Noncompliant",
                  "description": "This example demonstrates an LDAP connection where empty credentials are provided, leading to unauthenticated access which is insecure.",
                  "pattern": "ldap3\\.Connection\\(.*user=['\"]{0,1}['\"]{0,1},\\s*password=['\"]{0,1}['\"]{0,1}\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always use proper authentication mechanisms (e.g., Simple Authentication with valid credentials or SASL) when establishing LDAP connections.",
                "Avoid using anonymous or unauthenticated binds as they allow unauthorized access to directory data.",
                "Ensure that the LDAP server is configured to reject anonymous and unauthenticated connections.",
                "Regularly review and update LDAP connection practices to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "import ldap3\n\n# Compliant LDAP connection with simple bind authentication\nserver = ldap3.Server('ldap://example.com')\nconn = ldap3.Connection(server, user='cn=admin,dc=example,dc=com', password='secure_password', auto_bind=True)\n",
                  "description": "This compliant solution demonstrates establishing an LDAP connection with proper simple bind authentication, ensuring secure access."
                },
                {
                  "code": "import ldap3\n\n# Compliant LDAP connection using SASL authentication\nserver = ldap3.Server('ldap://example.com')\nconn = ldap3.Connection(server, authentication=ldap3.SASL, sasl_mechanism='GSSAPI', auto_bind=True)\n",
                  "description": "This example shows how to securely establish an LDAP connection using SASL authentication."
                }
              ]
            },
            "rationale": "Allowing anonymous or unauthenticated LDAP connections can enable attackers to access, modify, or exfiltrate sensitive directory data. By enforcing authenticated connections, organizations can prevent unauthorized access, protect sensitive information, and maintain the integrity of their directory services."
          },
          {
            "id": "python27",
            "title": "Cryptographic Key Generation Should Be Based on Strong Parameters",
            "description": "Detects instances where cryptographic keys are generated with weak or insecure parameters, making the encrypted data vulnerable to attacks aimed at recovering the plaintext. Using strong and well-validated key generation practices is crucial for maintaining the security and privacy of encrypted data.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "cryptography", "encryption", "key generation", "cwe", "privacy", "python3"],
            "severity": "Critical",
            "cwe": "CWE-329: Not Using a Random IV with CBC Mode",
            "examples": {
              "positive": [
                {
                  "code": "from cryptography.hazmat.primitives.asymmetric import rsa\n\n# Secure RSA key generation with strong parameters\nkey = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048\n)\n",
                  "description": "This compliant code example demonstrates secure RSA key generation using strong parameters, ensuring that the generated key provides sufficient security against attacks."
                },
                {
                  "code": "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\n\n# Secure key derivation using PBKDF2HMAC with strong parameters\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA256(),\n    length=32,\n    salt=os.urandom(16),\n    iterations=100000,\n    backend=default_backend()\n)\nkey = kdf.derive(b'my_secure_password')\n",
                  "description": "This example shows how to securely derive a cryptographic key using PBKDF2HMAC with strong parameters, including a high iteration count and a secure hash algorithm."
                }
              ],
              "negative": [
                {
                  "code": "from cryptography.hazmat.primitives.asymmetric import rsa\n\n# Insecure RSA key generation with weak parameters\nkey = rsa.generate_private_key(\n    public_exponent=3,\n    key_size=512\n)  # Noncompliant",
                  "description": "This noncompliant code example generates an RSA key with weak parameters, such as a small key size and a low public exponent, making the key vulnerable to attacks.",
                  "pattern": "rsa\\.generate_private_key\\(\\s*public_exponent=3\\s*,\\s*key_size=512\\s*\\)"
                },
                {
                  "code": "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\n\n# Insecure key derivation with weak parameters\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA1(),\n    length=16,\n    salt=b'static_salt',\n    iterations=1000,\n    backend=default_backend()\n)\nkey = kdf.derive(b'weak_password')  # Noncompliant",
                  "description": "This example demonstrates insecure key derivation using PBKDF2HMAC with weak parameters, such as a low iteration count, an insecure hash algorithm, and a static salt, making the derived key vulnerable to attacks.",
                  "pattern": "PBKDF2HMAC\\(\\s*algorithm=hashes\\.SHA1\\(\\)\\s*,\\s*length=16\\s*,\\s*salt=b'static_salt'\\s*,\\s*iterations=1000\\s*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always use strong and well-validated parameters when generating cryptographic keys, such as sufficient key size and secure algorithms.",
                "Avoid using weak public exponents or small key sizes in RSA key generation.",
                "For key derivation, use strong hash algorithms like SHA-256 and ensure a high iteration count.",
                "Use a securely generated random salt for key derivation functions.",
                "Regularly review and update cryptographic practices to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "from cryptography.hazmat.primitives.asymmetric import rsa\n\n# Compliant RSA key generation with strong parameters\nkey = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048\n)\n",
                  "description": "This compliant solution demonstrates secure RSA key generation using strong parameters to ensure robust security."
                },
                {
                  "code": "from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\n\n# Secure key derivation using PBKDF2HMAC with strong parameters\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA256(),\n    length=32,\n    salt=os.urandom(16),\n    iterations=100000,\n    backend=default_backend()\n)\nkey = kdf.derive(b'my_secure_password')\n",
                  "description": "This example demonstrates secure key derivation using PBKDF2HMAC with strong parameters, ensuring that the derived key is resistant to attacks."
                }
              ]
            },
            "rationale": "Weak cryptographic key generation exposes encrypted data to significant risks, including potential plaintext recovery by attackers. By ensuring that cryptographic keys are generated with strong parameters, organizations can better protect sensitive information and maintain the integrity and confidentiality of their data."
          },
          {
            "id": "python28",
            "title": "Weak SSL/TLS Protocols Should Not Be Used",
            "description": "Detects instances where weak SSL/TLS protocols, such as SSL 1.0, 2.0, 3.0, and TLS 1.0, 1.1, are used, making encrypted data vulnerable to attacks aimed at recovering the plaintext. Using strong and up-to-date SSL/TLS protocols is crucial for maintaining the security and privacy of communications.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "ssl", "tls", "cryptography", "cwe", "privacy", "python3"],
            "severity": "Critical",
            "cwe": "CWE-327: Use of a Broken or Risky Cryptographic Algorithm",
            "examples": {
              "positive": [
                {
                  "code": "import ssl\n\n# Secure SSL/TLS context creation with strong protocols\ncontext = ssl.create_default_context()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n",
                  "description": "This compliant code example demonstrates the creation of an SSL/TLS context that explicitly disables weak protocols such as TLS 1.0 and TLS 1.1, ensuring that only strong protocols are used."
                },
                {
                  "code": "import ssl\n\n# Secure SSL/TLS context with only TLS 1.2 and higher allowed\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS)\ncontext.options |= ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3 | ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n",
                  "description": "This example shows how to configure an SSL/TLS context to only allow TLS 1.2 and higher, thereby avoiding the use of deprecated and insecure protocols."
                }
              ],
              "negative": [
                {
                  "code": "import ssl\n\n# Insecure SSL/TLS context with SSLv3 enabled\ncontext = ssl.SSLContext(ssl.PROTOCOL_SSLv3)  # Noncompliant",
                  "description": "This noncompliant code example creates an SSL/TLS context with the SSLv3 protocol enabled, which is considered insecure and vulnerable to various attacks.",
                  "pattern": "ssl\\.SSLContext\\(ssl\\.PROTOCOL_SSLv3\\)"
                },
                {
                  "code": "import ssl\n\n# Insecure SSL/TLS context with TLS 1.0 and 1.1 enabled\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)  # Noncompliant",
                  "description": "This example demonstrates the creation of an SSL/TLS context that allows the use of the deprecated TLS 1.0 protocol, making it vulnerable to known attacks.",
                  "pattern": "ssl\\.SSLContext\\(ssl\\.PROTOCOL_TLSv1\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always use strong and up-to-date SSL/TLS protocols such as TLS 1.2 or TLS 1.3 when configuring SSL/TLS contexts.",
                "Explicitly disable weak and deprecated protocols (SSL 1.0, 2.0, 3.0, TLS 1.0, 1.1) in your SSL/TLS configurations.",
                "Regularly review and update SSL/TLS practices to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "import ssl\n\n# Compliant SSL/TLS context creation\ncontext = ssl.create_default_context()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n",
                  "description": "This compliant solution demonstrates how to create an SSL/TLS context that only allows strong protocols, ensuring secure communication."
                },
                {
                  "code": "import ssl\n\n# Secure SSL/TLS context with strong protocols only\ncontext = ssl.SSLContext(ssl.PROTOCOL_TLS)\ncontext.options |= ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3 | ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n",
                  "description": "This example shows how to configure an SSL/TLS context that disables weak protocols, ensuring that only TLS 1.2 and higher are allowed."
                }
              ]
            },
            "rationale": "Using weak SSL/TLS protocols exposes encrypted data to significant risks, including potential plaintext recovery by attackers. By ensuring that only strong and secure protocols are used, organizations can better protect sensitive information and maintain the integrity and confidentiality of their communications."
          },
          {
            "id": "python29",
            "title": "Cipher Block Chaining (CBC) IVs Should Be Unpredictable",
            "description": "Detects instances where predictable or static Initialization Vectors (IVs) are used in Cipher Block Chaining (CBC) mode, making encrypted data vulnerable to attacks aimed at recovering the plaintext. Using unpredictable and securely generated IVs is crucial for maintaining the security and privacy of encrypted data.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "cryptography", "encryption", "cbc", "iv", "cwe", "privacy", "python3"],
            "severity": "Critical",
            "cwe": "CWE-329: Not Using a Random IV with CBC Mode",
            "examples": {
              "positive": [
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives import padding\nfrom cryptography.hazmat.backends import default_backend\nimport os\n\n# Secure CBC mode encryption with a random IV\nkey = os.urandom(32)\niv = os.urandom(16)\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\nencryptor = cipher.encryptor()\npadder = padding.PKCS7(128).padder()\npadded_data = padder.update(b'sensitive data') + padder.finalize()\nciphertext = encryptor.update(padded_data) + encryptor.finalize()\n",
                  "description": "This compliant code example demonstrates how to securely generate a random IV for CBC mode encryption, ensuring that each encryption session uses a unique and unpredictable IV."
                }
              ],
              "negative": [
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives import padding\nfrom cryptography.hazmat.backends import default_backend\n\n# Insecure CBC mode encryption with a static IV\nkey = b'static_key_used_for_testing'\niv = b'1234567890123456'  # Noncompliant\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\nencryptor = cipher.encryptor()\npadder = padding.PKCS7(128).padder()\npadded_data = padder.update(b'sensitive data') + padder.finalize()\nciphertext = encryptor.update(padded_data) + encryptor.finalize()\n",
                  "description": "This noncompliant code example uses a static and predictable IV for CBC mode encryption, making the encryption vulnerable to attacks.",
                  "pattern": "modes\\.CBC\\(b['\"][a-zA-Z0-9]{16}['\"]\\)"
                },
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives import padding\nfrom cryptography.hazmat.backends import default_backend\nimport os\n\n# Insecure CBC mode encryption with a hardcoded IV\nkey = os.urandom(32)\niv = b'fixediv123456789'  # Noncompliant\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\nencryptor = cipher.encryptor()\npadder = padding.PKCS7(128).padder()\npadded_data = padder.update(b'sensitive data') + padder.finalize()\nciphertext = encryptor.update(padded_data) + encryptor.finalize()\n",
                  "description": "This example demonstrates the use of a hardcoded IV for CBC mode encryption, which is insecure as it makes the encryption predictable and vulnerable.",
                  "pattern": "modes\\.CBC\\(b['\"][a-zA-Z0-9]{16}['\"]\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always use a securely generated random IV for each encryption session when using CBC mode.",
                "Avoid using static or hardcoded IVs as they make the encryption predictable and vulnerable to attacks.",
                "Ensure that the IV is the correct length for the block size of the encryption algorithm (e.g., 16 bytes for AES).",
                "Regularly review and update cryptographic practices to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives import padding\nfrom cryptography.hazmat.backends import default_backend\nimport os\n\n# Compliant CBC mode encryption with a random IV\nkey = os.urandom(32)\niv = os.urandom(16)\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\nencryptor = cipher.encryptor()\npadder = padding.PKCS7(128).padder()\npadded_data = padder.update(b'sensitive data') + padder.finalize()\nciphertext = encryptor.update(padded_data) + encryptor.finalize()\n",
                  "description": "This compliant solution demonstrates secure CBC mode encryption with a random IV, ensuring that each encryption session is unique and secure."
                }
              ]
            },
            "rationale": "Using predictable or static IVs in CBC mode significantly weakens the security of the encryption, as it allows attackers to identify patterns in the ciphertext and potentially recover the plaintext. By ensuring that IVs are random and unique for each encryption session, organizations can better protect sensitive information and maintain the integrity and confidentiality of their encrypted data."
          },
          {
            "id": "python30",
            "title": "Regular Expressions Should Not Be Vulnerable to Denial of Service (DoS) Attacks",
            "description": "Detects instances where regular expressions could be vulnerable to Denial of Service (DoS) attacks due to untrusted or user-supplied data being used directly in the regex. Such vulnerabilities can lead to catastrophic backtracking, making the application unresponsive or inaccessible. Ensuring that regular expressions are properly constructed and validated is crucial for preventing DoS attacks.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "regex", "dos", "cwe", "python3"],
            "severity": "Critical",
            "cwe": "CWE-1333: Inefficient Regular Expression Complexity",
            "examples": {
              "positive": [
                {
                  "code": "import re\n\n# Secure regex pattern with limited input from user\npattern = re.compile(r'^[a-zA-Z0-9]{1,20}$')\ninput_data = 'safe_input'\nresult = pattern.match(input_data)\n",
                  "description": "This compliant code example demonstrates how to safely use a regular expression with a well-defined and constrained pattern, ensuring that user input does not lead to catastrophic backtracking."
                },
                {
                  "code": "import re\n\n# Secure regex pattern using re.escape to sanitize user input\nuser_input = '.*'\npattern = re.compile(re.escape(user_input))\nresult = pattern.match('safe_input')\n",
                  "description": "This example shows how to securely use user input in a regex pattern by escaping potentially dangerous characters, preventing the risk of catastrophic backtracking."
                }
              ],
              "negative": [
                {
                  "code": "import re\n\n# Insecure regex pattern using untrusted user input\nuser_input = '.*'\npattern = re.compile(user_input)  # Noncompliant\nresult = pattern.match('some_input')\n",
                  "description": "This noncompliant code example uses untrusted user input directly in a regex pattern, which can lead to catastrophic backtracking and potential DoS attacks.",
                  "pattern": "re\\.compile\\(.*user_input.*\\)"
                },
                {
                  "code": "import re\n\n# Insecure regex pattern with potential for catastrophic backtracking\npattern = re.compile(r'(a+)+$')  # Noncompliant\nresult = pattern.match('aaaaaaaaaaaaaaaaaaaaX')\n",
                  "description": "This example demonstrates a regex pattern that is susceptible to catastrophic backtracking, making it vulnerable to DoS attacks if exploited with carefully crafted input.",
                  "pattern": "re\\.compile\\(r'(.*\\+.*){2,}'\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Avoid using untrusted or user-supplied data directly in regular expressions. If necessary, sanitize input using `re.escape()` to prevent injection vulnerabilities.",
                "Limit the complexity of regular expressions by avoiding patterns that can lead to catastrophic backtracking, such as nested quantifiers (e.g., `(a+)+`).",
                "Test regular expressions with edge cases to ensure they perform efficiently and do not introduce performance bottlenecks.",
                "Regularly review and update regex patterns to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "import re\n\n# Compliant regex pattern with sanitized user input\nuser_input = '.*'\npattern = re.compile(re.escape(user_input))\nresult = pattern.match('safe_input')\n",
                  "description": "This compliant solution demonstrates how to securely use a regex pattern by escaping user input to prevent injection and backtracking vulnerabilities."
                },
                {
                  "code": "import re\n\n# Secure regex pattern avoiding catastrophic backtracking\npattern = re.compile(r'^[a-zA-Z0-9]{1,20}$')\nresult = pattern.match('safe_input')\n",
                  "description": "This example demonstrates a secure regex pattern that avoids nested quantifiers and limits input size, preventing catastrophic backtracking."
                }
              ]
            },
            "rationale": "Regular expression Denial of Service (ReDoS) attacks can make applications unresponsive by exploiting regex patterns that lead to catastrophic backtracking. By avoiding the use of untrusted data in regex patterns and designing efficient and secure regex patterns, organizations can prevent these vulnerabilities and ensure the availability and performance of their applications."
          },
          {
            "id": "python31",
            "title": "Password Hashing Functions Should Use an Unpredictable Salt",
            "description": "Detects instances where password hashing functions are used without an unpredictable salt, making the hashed passwords vulnerable to attacks such as precomputed hash attacks (e.g., rainbow tables). Using a unique, random salt for each password ensures that even identical passwords produce different hashes, significantly enhancing security.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "password", "hashing", "salt", "cwe", "python3"],
            "severity": "Critical",
            "cwe": "CWE-759: Use of a One-Way Hash without a Salt",
            "examples": {
              "positive": [
                {
                  "code": "import os\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\n\n# Secure password hashing with a random salt\nsalt = os.urandom(16)\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA256(),\n    length=32,\n    salt=salt,\n    iterations=100000,\n    backend=default_backend()\n)\nhash = kdf.derive(b'my_secure_password')\n",
                  "description": "This compliant code example demonstrates how to securely hash a password using PBKDF2HMAC with a unique, random salt for each password, ensuring that even identical passwords produce different hashes."
                }
              ],
              "negative": [
                {
                  "code": "from hashlib import sha256\n\n# Insecure password hashing without a salt\npassword = 'password123'\nhash = sha256(password.encode()).hexdigest()  # Noncompliant\n",
                  "description": "This noncompliant code example hashes a password without using a salt, making the hash vulnerable to precomputed hash attacks such as rainbow tables.",
                  "pattern": "sha256\\(.*password\\.encode\\(\\)\\)"
                },
                {
                  "code": "import os\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\n\n# Insecure password hashing with a static salt\nsalt = b'static_salt_value'  # Noncompliant\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA256(),\n    length=32,\n    salt=salt,\n    iterations=100000,\n    backend=default_backend()\n)\nhash = kdf.derive(b'my_secure_password')\n",
                  "description": "This example demonstrates insecure password hashing using a static salt, which can lead to identical hashes for identical passwords, weakening the security of the hashed passwords.",
                  "pattern": "salt\\s*=\\s*b['\"][a-zA-Z0-9]+['\"]"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always use a securely generated random salt for each password when hashing to ensure that even identical passwords produce different hashes.",
                "Avoid using static or hardcoded salts, as they compromise the uniqueness and security of the password hashes.",
                "Use cryptographic functions specifically designed for password hashing, such as PBKDF2, bcrypt, scrypt, or Argon2, which incorporate salts and are resistant to brute-force attacks.",
                "Regularly review and update password hashing practices to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "import os\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\n\n# Compliant password hashing with a random salt\nsalt = os.urandom(16)\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA256(),\n    length=32,\n    salt=salt,\n    iterations=100000,\n    backend=default_backend()\n)\nhash = kdf.derive(b'my_secure_password')\n",
                  "description": "This compliant solution demonstrates how to securely hash a password using PBKDF2HMAC with a unique, random salt, ensuring that each password hash is unique and secure."
                }
              ]
            },
            "rationale": "Using an unpredictable, unique salt for each password when hashing significantly increases the security of the stored passwords by preventing attackers from using precomputed hash attacks, such as rainbow tables, to crack the passwords. By ensuring that even identical passwords result in different hashes, the risk of password compromise is greatly reduced."
          },
          {
            "id": "python32",
            "title": "GraphQL Introspection Should Be Disabled in Production",
            "description": "Detects instances where GraphQL introspection is enabled in production environments, which can expose information about all available APIs and data structures to attackers. Disabling introspection in production reduces the risk of exposing sensitive information and private APIs.",
            "impact": "Major",
            "category": "Security",
            "tags": ["security", "vulnerability", "major", "graphql", "introspection", "cwe", "privacy", "python3"],
            "severity": "Major",
            "cwe": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor",
            "examples": {
              "positive": [
                {
                  "code": "from graphql import GraphQLSchema\n\n# Secure configuration with introspection disabled\nschema = GraphQLSchema(\n    query=QueryType,\n    mutation=MutationType,\n    types=[CustomType],\n    introspection=False  # Introspection disabled in production\n)\n",
                  "description": "This compliant code example demonstrates how to disable GraphQL introspection in production, preventing unauthorized access to schema information."
                },
                {
                  "code": "from ariadne import make_executable_schema\n\n# Secure configuration with introspection disabled\nschema = make_executable_schema(\n    type_defs,\n    resolvers,\n    enable_introspection=False  # Introspection disabled for security\n)\n",
                  "description": "This example shows how to configure the Ariadne GraphQL library to disable introspection, ensuring that the schema details are not exposed in production."
                }
              ],
              "negative": [
                {
                  "code": "from graphql import GraphQLSchema\n\n# Insecure configuration with introspection enabled in production\nschema = GraphQLSchema(\n    query=QueryType,\n    mutation=MutationType,\n    types=[CustomType],\n    introspection=True  # Noncompliant: Introspection enabled\n)\n",
                  "description": "This noncompliant code example enables GraphQL introspection in production, which can expose sensitive API information to attackers.",
                  "pattern": "GraphQLSchema\\(.*introspection=True.*\\)"
                },
                {
                  "code": "from ariadne import make_executable_schema\n\n# Insecure configuration with introspection enabled\nschema = make_executable_schema(\n    type_defs,\n    resolvers,\n    enable_introspection=True  # Noncompliant: Introspection enabled\n)\n",
                  "description": "This example demonstrates an insecure configuration where GraphQL introspection is enabled, potentially exposing schema information to unauthorized users.",
                  "pattern": "make_executable_schema\\(.*enable_introspection=True.*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Disable GraphQL introspection in production environments to prevent unauthorized access to schema details.",
                "Use feature flags or environment variables to dynamically control the availability of introspection based on the environment (e.g., enabled in development but disabled in production).",
                "Ensure that introspection is only enabled during development and testing phases where it's needed for debugging and API exploration.",
                "Regularly review and update your GraphQL API configurations to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "from graphql import GraphQLSchema\n\n# Compliant configuration with introspection disabled in production\nschema = GraphQLSchema(\n    query=QueryType,\n    mutation=MutationType,\n    types=[CustomType],\n    introspection=False  # Introspection disabled in production\n)\n",
                  "description": "This compliant solution demonstrates how to securely configure a GraphQL schema with introspection disabled in production environments."
                },
                {
                  "code": "from ariadne import make_executable_schema\n\n# Secure configuration with introspection disabled\nschema = make_executable_schema(\n    type_defs,\n    resolvers,\n    enable_introspection=False  # Introspection disabled for security\n)\n",
                  "description": "This example shows how to securely configure the Ariadne GraphQL library with introspection disabled, ensuring schema details are not exposed in production."
                }
              ]
            },
            "rationale": "GraphQL introspection in production environments can expose sensitive API information, making it easier for attackers to discover and exploit potential vulnerabilities. By disabling introspection in production, organizations can reduce the attack surface and protect private APIs and sensitive data."
          },
          {
            "id": "python33",
            "title": "Stack-Traces Should Not Be Disclosed",
            "description": "Detects instances where stack traces are exposed in error messages, which can reveal sensitive information about the application's architecture, logic, and potential vulnerabilities. To prevent attackers from exploiting these insights, stack traces should be handled securely and not disclosed in production environments.",
            "impact": "Major",
            "category": "Security",
            "tags": ["security", "vulnerability", "major", "stack trace", "error handling", "cwe", "python3"],
            "severity": "Major",
            "cwe": "CWE-209: Information Exposure Through an Error Message",
            "examples": {
              "positive": [
                {
                  "code": "import logging\n\n# Secure error handling without disclosing stack trace\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError as e:\n    logging.error('An error occurred: %s', e)  # Logging the error without stack trace\n    # Return a generic error message to the user\n    print('An unexpected error occurred. Please try again later.')\n",
                  "description": "This compliant code example demonstrates secure error handling by logging the error without exposing the stack trace and returning a generic error message to the user."
                },
                {
                  "code": "import logging\nimport traceback\n\n# Secure error handling with optional stack trace logging (not exposed to user)\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError:\n    logging.error('An error occurred: %s', traceback.format_exc())  # Stack trace logged securely\n    # Return a generic error message to the user\n    print('An error occurred. Please contact support.')\n",
                  "description": "This example shows secure error handling where the stack trace is logged for internal purposes but not exposed to the end user, protecting sensitive application details."
                }
              ],
              "negative": [
                {
                  "code": "try:\n    result = 1 / 0\nexcept ZeroDivisionError as e:\n    print(e)  # Noncompliant: Exposes stack trace to the user\n",
                  "description": "This noncompliant code example exposes the stack trace directly to the user, revealing sensitive information that could be exploited by attackers.",
                  "pattern": "print\\(e\\)|print\\(traceback\\.format_exc\\(\\)\\)"
                },
                {
                  "code": "try:\n    result = 1 / 0\nexcept ZeroDivisionError:\n    raise  # Noncompliant: Stack trace is exposed by re-raising the exception\n",
                  "description": "This example shows an insecure practice where the exception is re-raised, leading to the exposure of the stack trace to the user, which can reveal sensitive details about the application's internals.",
                  "pattern": "raise$"
                }
              ]
            },
            "fix": {
              "steps": [
                "Avoid exposing stack traces in error messages that are shown to end users. Instead, log the stack trace securely for internal purposes only.",
                "Use generic error messages when handling exceptions in production to prevent disclosing sensitive application details.",
                "Ensure that detailed error information, including stack traces, is only available in development or testing environments, not in production.",
                "Regularly review and update error handling practices to align with current security standards and best practices."
              ],
              "examples": [
                {
                  "code": "import logging\n\n# Compliant error handling with no stack trace exposure\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError as e:\n    logging.error('An error occurred: %s', e)  # Error is logged without exposing the stack trace\n    print('An unexpected error occurred. Please try again later.')\n",
                  "description": "This compliant solution demonstrates how to securely handle errors by logging them without exposing stack traces to the user, providing only a generic message."
                },
                {
                  "code": "import logging\nimport traceback\n\n# Secure logging of stack trace without user exposure\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError:\n    logging.error('An error occurred: %s', traceback.format_exc())  # Stack trace is logged internally\n    print('An error occurred. Please contact support.')\n",
                  "description": "This example shows how to log the stack trace securely without exposing it to the user, ensuring sensitive details remain protected."
                }
              ]
            },
            "rationale": "Stack traces can reveal sensitive information about the application's internals, including file paths, code structure, and potential vulnerabilities. Exposing this information in error messages allows attackers to gain insights that can be used to exploit the system. By handling errors securely and logging stack traces without exposing them to users, organizations can protect their applications from potential attacks."
          },
          {
            "id": "python34",
            "title": "Loop Boundaries Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where loop boundaries are susceptible to injection attacks, which can lead to operational overloads, technical denial of service, or business disruptions. To mitigate this risk, data inserted into loops must be sanitized before use.",
            "impact": "Major",
            "category": "Security",
            "tags": ["security", "vulnerability", "major", "loop boundary", "injection", "cwe", "python3"],
            "severity": "Major",
            "cwe": "CWE-606: Unchecked Input for Loop Condition",
            "examples": {
              "positive": [
                {
                  "code": "import re\n\n# Secure loop boundary handling with input validation\nuser_input = '10'\nif re.match(r'^\\d+$', user_input):  # Validate input is numeric\n    iterations = int(user_input)\n    for i in range(iterations):\n        print(f'Iteration {i+1}')\nelse:\n    print('Invalid input provided.')\n",
                  "description": "This compliant code example demonstrates secure handling of loop boundaries by validating that user input is numeric before using it in a loop."
                },
                {
                  "code": "import re\n\n# Secure loop boundary handling with capped input values\nuser_input = '1000'\nmax_iterations = 100  # Define a maximum limit for loop iterations\nif re.match(r'^\\d+$', user_input):\n    iterations = min(int(user_input), max_iterations)  # Cap the input to a safe limit\n    for i in range(iterations):\n        print(f'Iteration {i+1}')\nelse:\n    print('Invalid input provided.')\n",
                  "description": "This example shows how to enforce a maximum limit on loop iterations, even if the input is numeric, to prevent excessive resource consumption."
                }
              ],
              "negative": [
                {
                  "code": "user_input = input('Enter number of iterations: ')\nfor i in range(int(user_input)):\n    print(f'Iteration {i+1}')\n",
                  "description": "This noncompliant code example directly uses user input in a loop without validation, making it vulnerable to injection attacks that could cause excessive iterations.",
                  "pattern": "for i in range\\(int\\(.*input.*\\)\\)"
                },
                {
                  "code": "third_party_data = fetch_data()\nfor i in range(third_party_data.get('iterations', 10)):\n    process(i)\n",
                  "description": "This example demonstrates insecure use of third-party data for loop boundaries without validation, which can result in operational overloads.",
                  "pattern": "for i in range\\(.*third_party_data.*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always validate user or third-party input before using it to determine loop boundaries.",
                "Use regular expressions or other validation techniques to ensure the input is within an expected range.",
                "Enforce a maximum limit on loop iterations, even for valid input, to prevent excessive resource consumption.",
                "Review and update loop handling practices regularly to align with security best practices."
              ],
              "examples": [
                {
                  "code": "import re\n\n# Compliant loop boundary handling with validation\nuser_input = input('Enter number of iterations: ')\nif re.match(r'^\\d+$', user_input):\n    iterations = min(int(user_input), 100)  # Cap the iterations to a safe maximum\n    for i in range(iterations):\n        print(f'Iteration {i+1}')\nelse:\n    print('Invalid input provided.')\n",
                  "description": "This compliant solution shows how to safely handle loop boundaries by validating and capping user input."
                },
                {
                  "code": "def safe_fetch_iterations(data):\n    iterations = data.get('iterations', 10)\n    if isinstance(iterations, int) and 0 <= iterations <= 100:\n        return iterations\n    return 10  # Default to a safe value\n\n# Use the safe method to determine loop boundaries\nfor i in range(safe_fetch_iterations(third_party_data)):\n    process(i)\n",
                  "description": "This example demonstrates secure handling of loop boundaries by validating and defaulting to a safe number of iterations when using third-party data."
                }
              ]
            },
            "rationale": "Loop boundary injections can lead to significant vulnerabilities, including denial of service, by causing loops to execute more times than intended. Proper validation and limiting of input used in loop boundaries protect the application from these attacks, ensuring stability and security."
          },
          {
            "id": "python35",
            "title": "Memory Allocations Should Not Be Vulnerable to Denial of Service Attacks",
            "description": "Detects instances where memory allocations are susceptible to injection attacks, which can lead to excessive memory consumption, potential denial of service, or system instability. To mitigate this risk, memory allocation sizes must be validated and limited appropriately.",
            "impact": "Major",
            "category": "Security",
            "tags": ["security", "vulnerability", "major", "memory allocation", "denial of service", "cwe", "python3"],
            "severity": "Major",
            "cwe": "CWE-789: Uncontrolled Memory Allocation",
            "examples": {
              "positive": [
                {
                  "code": "import re\n\n# Secure memory allocation with input validation\nuser_input = '1024'\nif re.match(r'^\\d+$', user_input):  # Validate input is numeric\n    allocation_size = int(user_input)\n    if allocation_size > 0 and allocation_size <= 1024:  # Limit allocation to a safe size\n        data = bytearray(allocation_size)\n        print('Memory allocated safely.')\n    else:\n        print('Requested allocation size is too large.')\nelse:\n    print('Invalid input provided.')\n",
                  "description": "This compliant code example demonstrates secure handling of memory allocation by validating that user input is numeric and within a safe range before allocating memory."
                },
                {
                  "code": "import re\n\n# Secure memory allocation with capped input values\nuser_input = '2048'\nmax_allocation = 1024  # Define a maximum memory allocation size\nif re.match(r'^\\d+$', user_input):\n    allocation_size = min(int(user_input), max_allocation)  # Cap the input to a safe limit\n    data = bytearray(allocation_size)\n    print('Memory allocated with a safe limit.')\nelse:\n    print('Invalid input provided.')\n",
                  "description": "This example shows how to enforce a maximum limit on memory allocation size, even if the input is valid, to prevent excessive memory consumption."
                }
              ],
              "negative": [
                {
                  "code": "user_input = input('Enter memory allocation size: ')\ndata = bytearray(int(user_input))\n",
                  "description": "This noncompliant code example directly uses user input to determine memory allocation size without validation, making it vulnerable to injection attacks that could cause excessive memory consumption.",
                  "pattern": "bytearray\\(int\\(.*input.*\\)\\)"
                },
                {
                  "code": "third_party_data = fetch_data()\ndata = bytearray(third_party_data.get('size', 1024))\n",
                  "description": "This example demonstrates insecure use of third-party data for memory allocation size without validation, which can result in memory exhaustion.",
                  "pattern": "bytearray\\(.*third_party_data.*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always validate user or third-party input before using it to determine memory allocation size.",
                "Use regular expressions or other validation techniques to ensure the input is within an expected and safe range.",
                "Enforce a maximum limit on memory allocation size, even for valid input, to prevent excessive memory consumption.",
                "Review and update memory allocation practices regularly to align with security best practices."
              ],
              "examples": [
                {
                  "code": "import re\n\n# Compliant memory allocation handling with validation\nuser_input = input('Enter memory allocation size: ')\nif re.match(r'^\\d+$', user_input):\n    allocation_size = min(int(user_input), 1024)  # Cap the allocation size to a safe maximum\n    data = bytearray(allocation_size)\n    print('Memory allocated safely.')\nelse:\n    print('Invalid input provided.')\n",
                  "description": "This compliant solution shows how to safely handle memory allocation by validating and capping user input."
                },
                {
                  "code": "def safe_memory_allocation(data):\n    allocation_size = data.get('size', 1024)\n    if isinstance(allocation_size, int) and 0 <= allocation_size <= 1024:\n        return bytearray(allocation_size)\n    return bytearray(1024)  # Default to a safe allocation size\n\n# Use the safe method to allocate memory\nmemory_block = safe_memory_allocation(third_party_data)\n",
                  "description": "This example demonstrates secure handling of memory allocation by validating and defaulting to a safe size when using third-party data."
                }
              ]
            },
            "rationale": "Memory allocation injections can lead to significant vulnerabilities, including denial of service, by causing the application to consume excessive memory. Proper validation and limiting of input used in memory allocation protect the application and its hosting server from these attacks, ensuring stability and security."
          },
          {
            "id": "python36",
            "title": "Session Cookies Should Not Be Created from Untrusted Input",
            "description": "Detects instances where session cookies are generated from untrusted input, which can lead to security breaches, including session hijacking, sensitive data disclosure, and vulnerability chaining. To mitigate this risk, session cookies must be generated securely, without relying on untrusted data.",
            "impact": "Major",
            "category": "Security",
            "tags": ["security", "vulnerability", "major", "session cookies", "injection", "cwe", "python3"],
            "severity": "Major",
            "cwe": "CWE-384: Session Fixation",
            "examples": {
              "positive": [
                {
                  "code": "import secrets\n\n# Secure session cookie creation without using untrusted input\nsession_cookie = secrets.token_hex(16)\nresponse.set_cookie('session_id', session_cookie, httponly=True, secure=True)\n",
                  "description": "This compliant code example generates a secure session cookie using a cryptographically secure random value, without relying on any untrusted input."
                },
                {
                  "code": "import os\n\n# Secure session cookie creation with environment variables\nsession_cookie = os.getenv('SESSION_SECRET', os.urandom(16).hex())\nresponse.set_cookie('session_id', session_cookie, httponly=True, secure=True)\n",
                  "description": "This example demonstrates the secure generation of a session cookie, where a default secure value is used if an environment variable is not set."
                }
              ],
              "negative": [
                {
                  "code": "cookie_value = request.args.get('cookie')\nresponse.set_cookie('session_id', cookie_value)\n",
                  "description": "This noncompliant code example uses untrusted input (a GET parameter) to create a session cookie, making it vulnerable to session fixation attacks.",
                  "pattern": "set_cookie\\(.*request.args.get\\("
                },
                {
                  "code": "session_cookie = request.form['cookie_value']\nresponse.set_cookie('session_id', session_cookie)\n",
                  "description": "This example demonstrates insecure session cookie creation from form data, which can be manipulated by an attacker.",
                  "pattern": "set_cookie\\(.*request.form\\['cookie_value'\\]\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always generate session cookies using a cryptographically secure random value, such as those provided by libraries like `secrets` or `os` in Python.",
                "Avoid using any untrusted input, such as GET or POST parameters, to generate session cookies.",
                "Ensure session cookies are marked as HttpOnly and Secure to prevent exposure to client-side scripts and ensure transmission over secure channels.",
                "Review and update session management practices regularly to align with security best practices."
              ],
              "examples": [
                {
                  "code": "import secrets\n\n# Compliant session cookie creation using a secure random value\nsession_cookie = secrets.token_hex(16)\nresponse.set_cookie('session_id', session_cookie, httponly=True, secure=True)\n",
                  "description": "This compliant solution shows how to securely generate a session cookie using a cryptographically secure random value, ensuring that the cookie is safe from session fixation attacks."
                },
                {
                  "code": "import os\n\n# Secure session cookie creation with environment fallback\nsession_cookie = os.getenv('SESSION_SECRET', os.urandom(16).hex())\nresponse.set_cookie('session_id', session_cookie, httponly=True, secure=True)\n",
                  "description": "This example demonstrates a secure approach to session cookie creation, where an environment variable or a securely generated random value is used."
                }
              ]
            },
            "rationale": "Session cookies are critical to the security and integrity of user sessions in web applications. Creating session cookies from untrusted input exposes the application to significant risks, including session fixation and hijacking. By generating session cookies securely, organizations can protect their applications from these threats."
          },
          {
            "id": "python37",
            "title": "Server-Side Requests Should Not Be Vulnerable to Forging Attacks",
            "description": "Detects instances where server-side requests may be susceptible to forging attacks, such as SSRF, which can lead to unauthorized actions, data disclosure, or even remote command execution. To mitigate this risk, server-side requests must be carefully validated and restricted.",
            "impact": "Major",
            "category": "Security",
            "tags": ["security", "vulnerability", "major", "server-side request", "ssrf", "injection", "cwe", "python3"],
            "severity": "Major",
            "cwe": "CWE-918: Server-Side Request Forgery (SSRF)",
            "examples": {
              "positive": [
                {
                  "code": "import requests\nfrom urllib.parse import urlparse\n\n# Secure server-side request with URL validation\nurl = 'https://api.example.com/data'\nparsed_url = urlparse(url)\n\n# Allow only specific domains to be requested\nallowed_domains = ['api.example.com']\nif parsed_url.netloc in allowed_domains:\n    response = requests.get(url)\nelse:\n    raise ValueError('Unauthorized URL')\n",
                  "description": "This compliant code example ensures that server-side requests are made only to specific allowed domains, reducing the risk of SSRF."
                },
                {
                  "code": "import requests\n\n# Secure server-side request with IP range restriction\nurl = 'https://api.example.com/data'\nresponse = requests.get(url, allow_redirects=False)\n\n# Verify the response to ensure it hasn't been redirected to an unauthorized location\nif not response.is_redirect and 'api.example.com' in response.url:\n    data = response.json()\nelse:\n    raise ValueError('Potential SSRF detected')\n",
                  "description": "This example demonstrates how to secure server-side requests by restricting redirects and ensuring the final destination is within an allowed domain."
                }
              ],
              "negative": [
                {
                  "code": "import requests\n\n# Insecure server-side request vulnerable to SSRF\nurl = input('Enter the URL to fetch data from: ')\nresponse = requests.get(url)\ndata = response.json()\n",
                  "description": "This noncompliant code example allows user input to dictate the URL for a server-side request, making it vulnerable to SSRF attacks.",
                  "pattern": "requests\\.get\\(input\\("
                },
                {
                  "code": "import requests\n\n# Insecure server-side request with dynamic URL\nurl = 'http://' + user_input + '/data'\nresponse = requests.get(url)\n",
                  "description": "This example demonstrates an insecure server-side request that constructs the URL from untrusted user input, exposing the application to SSRF.",
                  "pattern": "requests\\.get\\('http://'\\+.*user_input"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always validate and sanitize URLs before using them in server-side requests.",
                "Restrict server-side requests to a whitelist of allowed domains or IP addresses.",
                "Avoid using user input directly to construct URLs for server-side requests.",
                "Disable or handle redirects carefully to prevent SSRF attacks.",
                "Review and update server-side request handling practices regularly to align with security best practices."
              ],
              "examples": [
                {
                  "code": "import requests\nfrom urllib.parse import urlparse\n\n# Compliant server-side request with domain validation\nurl = 'https://api.example.com/data'\nparsed_url = urlparse(url)\n\nallowed_domains = ['api.example.com']\nif parsed_url.netloc in allowed_domains:\n    response = requests.get(url)\n    data = response.json()\nelse:\n    raise ValueError('Unauthorized URL')\n",
                  "description": "This compliant solution shows how to securely handle server-side requests by validating the domain against a whitelist."
                },
                {
                  "code": "import requests\n\n# Secure server-side request with strict redirect handling\nurl = 'https://api.example.com/data'\nresponse = requests.get(url, allow_redirects=False)\n\nif not response.is_redirect and 'api.example.com' in response.url:\n    data = response.json()\nelse:\n    raise ValueError('Potential SSRF detected')\n",
                  "description": "This example demonstrates how to prevent SSRF by carefully handling redirects and ensuring requests only go to authorized destinations."
                }
              ]
            },
            "rationale": "Server-Side Request Forgery (SSRF) is a significant vulnerability that can allow attackers to perform unauthorized actions or access sensitive data by manipulating server-side requests. By validating and restricting the URLs and handling redirects securely, applications can protect against SSRF attacks."
          },
          {
            "id": "python38",
            "title": "Administration Services Access Should Be Restricted to Specific IP Addresses",
            "description": "Detects instances where access to administration services is not restricted to specific IP addresses, which can expose these services to unauthorized access and potential exploits. To mitigate this risk, access should be limited to a set of trusted IP addresses using firewall rules or cloud platform security settings.",
            "impact": "Minor",
            "category": "Security",
            "tags": ["security", "vulnerability", "minor", "administration services", "access control", "ip restriction", "cwe", "aws", "cloud"],
            "severity": "Minor",
            "cwe": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor",
            "examples": {
              "positive": [
                {
                  "code": "import boto3\n\n# Secure access control for AWS EC2 instances\nclient = boto3.client('ec2')\nresponse = client.describe_security_groups(GroupNames=['my-security-group'])\n\n# Update security group to allow access only from a specific IP address\nclient.authorize_security_group_ingress(\n    GroupName='my-security-group',\n    IpProtocol='tcp',\n    FromPort=22,\n    ToPort=22,\n    CidrIp='203.0.113.0/24'\n)\n",
                  "description": "This compliant code example demonstrates how to securely restrict SSH access to an EC2 instance by allowing traffic only from a specific IP address range."
                },
                {
                  "code": "import boto3\n\n# Secure access control for RDS instances\nclient = boto3.client('rds')\nresponse = client.modify_db_instance(\n    DBInstanceIdentifier='mydbinstance',\n    VpcSecurityGroupIds=['sg-0123456789abcdef0']\n)\n\n# Ensure the security group allows access only from trusted IP addresses\nclient.authorize_security_group_ingress(\n    GroupId='sg-0123456789abcdef0',\n    IpProtocol='tcp',\n    FromPort=3306,\n    ToPort=3306,\n    CidrIp='203.0.113.0/24'\n)\n",
                  "description": "This example shows how to restrict access to an AWS RDS instance, ensuring only specific IP addresses can connect to the database."
                }
              ],
              "negative": [
                {
                  "code": "import boto3\n\n# Insecure access control allowing SSH from any IP address\nclient = boto3.client('ec2')\nresponse = client.authorize_security_group_ingress(\n    GroupName='my-security-group',\n    IpProtocol='tcp',\n    FromPort=22,\n    ToPort=22,\n    CidrIp='0.0.0.0/0'\n)\n",
                  "description": "This noncompliant code example allows SSH access from any IP address, exposing the server to unauthorized access and potential exploits.",
                  "pattern": "authorize_security_group_ingress\\(.*CidrIp='0.0.0.0/0'\\)"
                },
                {
                  "code": "import boto3\n\n# Insecure access control allowing unrestricted database access\nclient = boto3.client('rds')\nresponse = client.modify_db_instance(\n    DBInstanceIdentifier='mydbinstance',\n    VpcSecurityGroupIds=['sg-0123456789abcdef0']\n)\n\n# Security group allows access from any IP address\nclient.authorize_security_group_ingress(\n    GroupId='sg-0123456789abcdef0',\n    IpProtocol='tcp',\n    FromPort=3306,\n    ToPort=3306,\n    CidrIp='0.0.0.0/0'\n)\n",
                  "description": "This example demonstrates insecure configuration of a security group, allowing unrestricted access to a database service, which could lead to unauthorized access.",
                  "pattern": "authorize_security_group_ingress\\(.*CidrIp='0.0.0.0/0'\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Configure security groups or firewall rules to restrict access to administration services to specific trusted IP addresses.",
                "Review and update firewall rules regularly to ensure that only authorized IP addresses have access to critical services.",
                "Avoid using overly permissive rules such as allowing access from all IP addresses (0.0.0.0/0).",
                "Utilize cloud platform features like AWS Security Groups, Azure Network Security Groups, or GCP Firewall Rules to enforce IP restrictions.",
                "Implement monitoring and alerting to detect unauthorized access attempts."
              ],
              "examples": [
                {
                  "code": "import boto3\n\n# Compliant security group configuration restricting SSH access\nclient = boto3.client('ec2')\nresponse = client.authorize_security_group_ingress(\n    GroupName='my-security-group',\n    IpProtocol='tcp',\n    FromPort=22,\n    ToPort=22,\n    CidrIp='203.0.113.0/24'\n)\n",
                  "description": "This compliant solution shows how to configure a security group to allow SSH access only from a specific IP address range, enhancing security."
                },
                {
                  "code": "import boto3\n\n# Secure RDS instance configuration with IP restriction\nclient = boto3.client('rds')\nresponse = client.modify_db_instance(\n    DBInstanceIdentifier='mydbinstance',\n    VpcSecurityGroupIds=['sg-0123456789abcdef0']\n)\n\nclient.authorize_security_group_ingress(\n    GroupId='sg-0123456789abcdef0',\n    IpProtocol='tcp',\n    FromPort=3306,\n    ToPort=3306,\n    CidrIp='203.0.113.0/24'\n)\n",
                  "description": "This example demonstrates how to configure a security group for an RDS instance to restrict database access to specific IP addresses, improving security."
                }
              ]
            },
            "rationale": "Administration services are critical entry points to cloud environments, and improper access control can lead to unauthorized access and potential exploits. By restricting access to these services to specific IP addresses, organizations can significantly reduce the risk of unauthorized access and protect their infrastructure."
          },
          {
            "id": "python39",
            "title": "Logging Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where untrusted input is logged without proper sanitization, which can lead to log injection attacks. These attacks can compromise the integrity of log files, making it difficult to trace malicious activities and potentially enabling further exploits.",
            "impact": "Minor",
            "category": "Security",
            "tags": ["security", "vulnerability", "minor", "log injection", "sanitization", "cwe", "python3"],
            "severity": "Minor",
            "cwe": "CWE-117: Improper Output Neutralization for Logs",
            "examples": {
              "positive": [
                {
                  "code": "import logging\n\n# Secure logging with newline character replacement\nuser_input = 'user123\\nadmin rights granted'\nclean_input = user_input.replace('\\n', '_')  # Replace newline characters\nlogging.info('User action: %s', clean_input)\n",
                  "description": "This compliant code example sanitizes user input by replacing newline characters before logging, preventing log injection attacks."
                },
                {
                  "code": "import logging\nimport re\n\n# Secure logging with regex sanitization\nuser_input = 'user123\\nadmin rights granted'\nclean_input = re.sub(r'[\\r\\n]', '_', user_input)  # Sanitize carriage returns and newlines\nlogging.info('User action: %s', clean_input)\n",
                  "description": "This example demonstrates secure logging by using a regex to sanitize newline and carriage return characters, ensuring the integrity of log files."
                }
              ],
              "negative": [
                {
                  "code": "import logging\n\n# Insecure logging vulnerable to injection attacks\nuser_input = 'user123\\nadmin rights granted'\nlogging.info('User action: %s', user_input)\n",
                  "description": "This noncompliant code example logs untrusted input directly, making it vulnerable to log injection attacks where an attacker can insert misleading or harmful log entries.",
                  "pattern": "logging\\.info\\(.*user_input.*\\)"
                },
                {
                  "code": "import logging\n\n# Insecure logging without input sanitization\nuser_input = request.form['username']\nlogging.info('Login attempt by user: %s', user_input)\n",
                  "description": "This example demonstrates insecure logging where untrusted input from a form is logged without sanitization, exposing the application to log injection attacks.",
                  "pattern": "logging\\.info\\(.*request\\.form\\['.*'\\].*\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Sanitize all user inputs or other untrusted data before logging, especially removing or replacing newline characters.",
                "Use regular expressions or other sanitization techniques to neutralize any potentially harmful characters in the input.",
                "Avoid logging raw user inputs directly; instead, use secure formatting and sanitization practices.",
                "Review and update logging practices regularly to align with security best practices and prevent log injection attacks."
              ],
              "examples": [
                {
                  "code": "import logging\n\n# Compliant logging with sanitization\nuser_input = 'user123\\nadmin rights granted'\nclean_input = user_input.replace('\\n', '_')  # Replace newline characters\nlogging.info('User action: %s', clean_input)\n",
                  "description": "This compliant solution shows how to securely log user input by replacing newline characters, preventing log injection attacks."
                },
                {
                  "code": "import logging\nimport re\n\n# Secure logging with regular expression sanitization\nuser_input = 'user123\\nadmin rights granted'\nclean_input = re.sub(r'[\\r\\n]', '_', user_input)  # Sanitize input using regex\nlogging.info('User action: %s', clean_input)\n",
                  "description": "This example demonstrates how to use regular expressions to sanitize user input before logging, ensuring log integrity and preventing injection attacks."
                }
              ]
            },
            "rationale": "Logging untrusted input without proper sanitization can lead to log injection attacks, where an attacker can forge or manipulate log entries. This compromises the integrity of the logs, potentially concealing malicious activities and enabling further exploits. By sanitizing input before logging, applications can maintain accurate and trustworthy logs."
          },
          {
            "id": "python40",
            "title": "HTML Autoescape Mechanism Should Not Be Globally Disabled",
            "description": "Detects instances where the HTML autoescape mechanism is globally disabled in template engines like Jinja2, which can expose web applications to cross-site scripting (XSS) vulnerabilities. To mitigate this risk, autoescaping should be enabled by default to ensure secure handling of template variables.",
            "impact": "Blocker",
            "category": "Security",
            "tags": ["security", "vulnerability", "blocker", "xss", "autoescape", "cwe", "python3", "jinja2", "django"],
            "severity": "Blocker",
            "cwe": "CWE-116: Improper Encoding or Escaping of Output",
            "examples": {
              "positive": [
                {
                  "code": "from jinja2 import Environment\n\n# Secure Jinja2 environment with autoescape enabled\nenv = Environment(autoescape=True)\n",
                  "description": "This compliant code example demonstrates the correct configuration of a Jinja2 environment with autoescaping enabled, protecting against XSS vulnerabilities."
                },
                {
                  "code": "from django.conf import settings\n\n# Ensure Django templates use autoescape by default\nsettings.configure(TEMPLATES=[\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'OPTIONS': {\n            'autoescape': True,\n        },\n    },\n])\n",
                  "description": "This example ensures that Django templates are configured with autoescaping enabled by default, reducing the risk of XSS attacks."
                }
              ],
              "negative": [
                {
                  "code": "from jinja2 import Environment\n\n# Insecure Jinja2 environment with autoescape disabled\nenv = Environment(autoescape=False)\n",
                  "description": "This noncompliant code example disables autoescaping in a Jinja2 environment, making the application vulnerable to XSS attacks.",
                  "pattern": "Environment\\(.*autoescape=False.*\\)"
                },
                {
                  "code": "from jinja2 import Environment\n\n# Insecure Jinja2 environment without autoescape configuration\nenv = Environment()  # Default autoescape is disabled\n",
                  "description": "This example demonstrates insecure use of Jinja2 where autoescaping is not explicitly enabled, leaving the application vulnerable to XSS.",
                  "pattern": "Environment\\(\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Ensure that autoescape is enabled by default in template engines like Jinja2 and Django.",
                "Review template engine configurations to verify that autoescape is not disabled globally.",
                "Manually disable autoescape only in specific, controlled contexts where it is safe to do so, and ensure that the output is properly sanitized.",
                "Regularly review and update template handling practices to align with security best practices and prevent XSS vulnerabilities."
              ],
              "examples": [
                {
                  "code": "from jinja2 import Environment\n\n# Compliant Jinja2 environment with autoescape enabled\nenv = Environment(autoescape=True)\n",
                  "description": "This compliant solution ensures that a Jinja2 environment is configured with autoescape enabled, protecting the application from XSS attacks."
                },
                {
                  "code": "from django.conf import settings\n\n# Ensure Django templates are configured securely\nsettings.configure(TEMPLATES=[\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'OPTIONS': {\n            'autoescape': True,\n        },\n    },\n])\n",
                  "description": "This example demonstrates how to securely configure Django templates with autoescape enabled by default, reducing the risk of XSS vulnerabilities."
                }
              ]
            },
            "rationale": "Disabling the HTML autoescape mechanism in template engines exposes web applications to cross-site scripting (XSS) vulnerabilities, which can lead to the execution of malicious scripts in users' browsers. By ensuring that autoescaping is enabled by default, developers can protect their applications from XSS attacks and ensure safer web interactions."
          },
          {
            "id": "python41",
            "title": "HTTP Response Headers Should Not Be Vulnerable to Injection Attacks",
            "description": "Detects instances where HTTP response headers are constructed using untrusted input without proper validation, making the application vulnerable to header injection attacks. These attacks can lead to security issues such as HTTP Response Splitting/Smuggling or the manipulation of security-sensitive headers.",
            "impact": "Critical",
            "category": "Security",
            "tags": ["security", "vulnerability", "critical", "header injection", "response splitting", "cwe", "python3", "flask", "django"],
            "severity": "Critical",
            "cwe": "CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')",
            "examples": {
              "positive": [
                {
                  "code": "from flask import Response, request\nfrom werkzeug.datastructures import Headers\nimport re\n\n@app.route('/route')\ndef route():\n    content_type = request.args.get('Content-Type')\n    allowed_content_types = r'application/(pdf|json|xml)'\n    response = Response()\n    headers = Headers()\n    if re.match(allowed_content_types, content_type):\n        headers.add('Content-Type', content_type)  # Compliant\n    else:\n        headers.add('Content-Type', 'application/json')\n    response.headers = headers\n    return response\n",
                  "description": "This compliant Flask code example ensures that the Content-Type header is only set to allowed values, protecting against header injection attacks."
                },
                {
                  "code": "import django.http\nimport re\n\n# Secure Django view with header validation\ndef route(request):\n    content_type = request.GET.get('Content-Type')\n    allowed_content_types = r'application/(pdf|json|xml)'\n    response = django.http.HttpResponse()\n    if re.match(allowed_content_types, content_type):\n        response.__setitem__('Content-Type', content_type)  # Compliant\n    else:\n        response.__setitem__('Content-Type', 'application/json')\n    return response\n",
                  "description": "This example demonstrates a secure Django view where the Content-Type header is validated against a whitelist before being set, preventing injection attacks."
                }
              ],
              "negative": [
                {
                  "code": "from flask import Response, request\nfrom werkzeug.datastructures import Headers\n\n@app.route('/route')\ndef route():\n    content_type = request.args['Content-Type']\n    response = Response()\n    headers = Headers()\n    headers.add('Content-Type', content_type)  # Noncompliant\n    response.headers = headers\n    return response\n",
                  "description": "This noncompliant Flask code example uses untrusted user input directly to set a response header, making it vulnerable to header injection attacks.",
                  "pattern": "headers\\.add\\(.*request\\.args\\[.*\\]\\)"
                },
                {
                  "code": "import django.http\n\n# Insecure Django view with unvalidated header\ndef route(request):\n    content_type = request.GET.get('Content-Type')\n    response = django.http.HttpResponse()\n    response.__setitem__('Content-Type', content_type)  # Noncompliant\n    return response\n",
                  "description": "This example demonstrates insecure use of user input to set an HTTP response header in Django, which could lead to injection attacks.",
                  "pattern": "response\\.__setitem__\\('Content-Type', request\\.GET\\.get\\('Content-Type'\\)\\)"
                }
              ]
            },
            "fix": {
              "steps": [
                "Always validate and sanitize user-provided data before using it to construct HTTP response headers.",
                "Use a whitelist approach to ensure that only allowed values are set in HTTP response headers.",
                "Avoid directly using untrusted input in response headers without proper validation or escaping.",
                "Review and update HTTP response header handling practices regularly to align with security best practices and prevent injection attacks."
              ],
              "examples": [
                {
                  "code": "from flask import Response, request\nfrom werkzeug.datastructures import Headers\nimport re\n\n@app.route('/route')\ndef route():\n    content_type = request.args.get('Content-Type')\n    allowed_content_types = r'application/(pdf|json|xml)'\n    response = Response()\n    headers = Headers()\n    if re.match(allowed_content_types, content_type):\n        headers.add('Content-Type', content_type)  # Compliant\n    else:\n        headers.add('Content-Type', 'application/json')\n    response.headers = headers\n    return response\n",
                  "description": "This compliant solution demonstrates how to safely set an HTTP response header in Flask by validating the input against a whitelist."
                },
                {
                  "code": "import django.http\nimport re\n\n# Secure Django view with header validation\ndef route(request):\n    content_type = request.GET.get('Content-Type')\n    allowed_content_types = r'application/(pdf|json|xml)'\n    response = django.http.HttpResponse()\n    if re.match(allowed_content_types, content_type):\n        response.__setitem__('Content-Type', content_type)  # Compliant\n    else:\n        response.__setitem__('Content-Type', 'application/json')\n    return response\n",
                  "description": "This compliant solution ensures that an HTTP response header in Django is set safely by validating the user input against a whitelist."
                }
              ]
            },
            "rationale": "HTTP response header injection attacks can lead to significant security vulnerabilities such as HTTP Response Splitting, Smuggling, or the manipulation of critical headers like CORS. By validating and sanitizing user-provided data before using it in HTTP response headers, applications can prevent these attacks and maintain a secure environment."
          }          
    ]
}
  
